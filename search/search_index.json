{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"py_ez_wikidata API Documentation","text":""},{"location":"#ez_wikidata.prefixes","title":"<code>prefixes</code>","text":"<p>Created on 2024-03-02</p> <p>@author: wf</p>"},{"location":"#ez_wikidata.prefixes.Prefixes","title":"<code>Prefixes</code>","text":"<p>handle standard Prefixes</p> Source code in <code>ez_wikidata/prefixes.py</code> <pre><code>class Prefixes:\n    \"\"\"\n    handle standard Prefixes\n    \"\"\"\n\n    @classmethod\n    def getPrefixes(\n        cls, prefixes=[\"rdf\", \"rdfs\", \"schema\", \"wd\", \"wdt\", \"wikibase\", \"xsd\"]\n    ):\n        prefixMap = {\n            \"bd\": \"&lt;http://www.bigdata.com/rdf#&gt;\",\n            \"cc\": \"&lt;http://creativecommons.org/ns#&gt;\",\n            \"dct\": \"&lt;http://purl.org/dc/terms/&gt;\",\n            \"geo\": \"&lt;http://www.opengis.net/ont/geosparql#&gt;\",\n            \"ontolex\": \"&lt;http://www.w3.org/ns/lemon/ontolex#&gt;\",\n            \"owl\": \"&lt;http://www.w3.org/2002/07/owl#&gt;\",\n            \"p\": \"&lt;http://www.wikidata.org/prop/&gt;\",\n            \"pq\": \"&lt;http://www.wikidata.org/prop/qualifier/&gt;\",\n            \"pqn\": \"&lt;http://www.wikidata.org/prop/qualifier/value-normalized/&gt;\",\n            \"pqv\": \"&lt;http://www.wikidata.org/prop/qualifier/value/&gt;\",\n            \"pr\": \"&lt;http://www.wikidata.org/prop/reference/&gt;\",\n            \"prn\": \"&lt;http://www.wikidata.org/prop/reference/value-normalized/&gt;\",\n            \"prov\": \"&lt;http://www.w3.org/ns/prov#&gt;\",\n            \"prv\": \"&lt;http://www.wikidata.org/prop/reference/value/&gt;\",\n            \"ps\": \"&lt;http://www.wikidata.org/prop/statement/&gt;\",\n            \"psn\": \"&lt;http://www.wikidata.org/prop/statement/value-normalized/&gt;\",\n            \"psv\": \"&lt;http://www.wikidata.org/prop/statement/value/&gt;\",\n            \"rdf\": \"&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\",\n            \"rdfs\": \"&lt;http://www.w3.org/2000/01/rdf-schema#&gt;\",\n            \"schema\": \"&lt;http://schema.org/&gt;\",\n            \"skos\": \"&lt;http://www.w3.org/2004/02/skos/core#&gt;\",\n            \"wd\": \"&lt;http://www.wikidata.org/entity/&gt;\",\n            \"wdata\": \"&lt;http://www.wikidata.org/wiki/Special:EntityData/&gt;\",\n            \"wdno\": \"&lt;http://www.wikidata.org/prop/novalue/&gt;\",\n            \"wdref\": \"&lt;http://www.wikidata.org/reference/&gt;\",\n            \"wds\": \"&lt;http://www.wikidata.org/entity/statement/&gt;\",\n            \"wdt\": \"&lt;http://www.wikidata.org/prop/direct/&gt;\",\n            \"wdtn\": \"&lt;http://www.wikidata.org/prop/direct-normalized/&gt;\",\n            \"wdv\": \"&lt;http://www.wikidata.org/value/&gt;\",\n            \"wikibase\": \"&lt;http://wikiba.se/ontology#&gt;\",\n            \"xsd\": \"&lt;http://www.w3.org/2001/XMLSchema#&gt;\",\n        }\n        # see also https://www.wikidata.org/wiki/EntitySchema:E49\n        sparql = \"\"\n        for prefix in prefixes:\n            if prefix in prefixMap:\n                sparql += f\"PREFIX {prefix}: {prefixMap[prefix]}\\n\"\n        return sparql\n</code></pre>"},{"location":"#ez_wikidata.trulytabular","title":"<code>trulytabular</code>","text":"<p>Created on 2022-04-14</p> <p>@author: wf</p>"},{"location":"#ez_wikidata.trulytabular.TrulyTabular","title":"<code>TrulyTabular</code>","text":"<p>               Bases: <code>object</code></p> <p>truly tabular SPARQL/RDF analysis</p> <p>checks \"how tabular\" a query based on a list of properties of an itemclass is</p> Source code in <code>ez_wikidata/trulytabular.py</code> <pre><code>class TrulyTabular(object):\n    \"\"\"\n    truly tabular SPARQL/RDF analysis\n\n    checks \"how tabular\" a query based on a list of properties of an itemclass is\n    \"\"\"\n\n    def __init__(\n        self,\n        itemQid,\n        propertyLabels: list = [],\n        propertyIds: list = [],\n        search_predicate=\"wdt:P31\",\n        where: str = None,\n        endpointConf=None,\n        lang=\"en\",\n        debug=False,\n    ):\n        \"\"\"\n        Constructor\n\n        Args:\n            itemQid(str): wikidata id of the type to analyze\n            propertyLabels(list): a list of labels of properties to be considered\n            propertyIds(list): a list of ids of properties to be considered\n            search_predicate(str): the search predicate to use e.g. instanceof / subclass of\n            where(str): extra where clause for instance selection (if any)\n            endpoint(str): the url of the SPARQL endpoint to be used\n        \"\"\"\n        self.itemQid = itemQid\n        self.debug = debug\n        if endpointConf is None:\n            endpointConf = Endpoint.getDefault()\n        self.endpointConf = endpointConf\n        self.wpm = WikidataPropertyManager.get_instance(\n            endpoint_url=endpointConf.endpoint\n        )\n        self.sparql = SPARQL(endpointConf.endpoint, method=self.endpointConf.method)\n        self.sparql.debug = self.debug\n        self.search_predicate = search_predicate\n        self.where = f\"\\n  {where}\" if where is not None else \"\"\n        self.lang = lang\n        self.item = WikidataItem(\n            itemQid, sparql=self.sparql, lang=lang, debug=self.debug\n        )\n        self.queryManager = TrulyTabular.getQueryManager(debug=self.debug)\n        self.properties = self.wpm.get_properties_by_ids(propertyIds)\n        self.properties.update(\n            self.wpm.get_properties_by_labels(propertyLabels, lang=lang)\n        )\n        self.isodate = datetime.datetime.now().isoformat()\n        self.error = None\n\n    def __str__(self):\n        \"\"\"\n        Returns:\n            str: my text representation\n        \"\"\"\n        return self.asText(long=False)\n\n    def count(self):\n        \"\"\"\n        get my count\n        \"\"\"\n        itemText = self.getItemText()\n        query = f\"\"\"# Count all items with the given type\n# {itemText}\n{Prefixes.getPrefixes()}\nSELECT (COUNT (DISTINCT ?item) AS ?count)\nWHERE\n{{\n  # instance of {self.item.qlabel}\n  ?item {self.search_predicate} wd:{self.item.qid}.{self.where}\n}}\"\"\"\n        try:\n            count = self.sparql.getValue(query, \"count\")\n            # workaround https://github.com/ad-freiburg/qlever/issues/717\n            count = int(count)\n        except Exception as ex:\n            self.error = ex\n            count = None\n\n        return count, query\n\n    def asText(self, long: bool = True):\n        \"\"\"\n        returns my content as a text representation\n\n        Args:\n            long(bool): True if a long format including url is wished\n\n        Returns:\n            str: a text representation of my content\n        \"\"\"\n        text = self.item.asText(long)\n        return text\n\n    def getItemText(self):\n        # leads to 405 Method not allowed in SPARQLWrapper under certain circumstances\n        # itemText=self.asText(long=True)\n        itemText = f\"{self.itemQid}:{self.item.qlabel}\"\n        return itemText\n\n    @classmethod\n    def getQueryManager(cls, lang=\"sparql\", name=\"trulytabular\", debug=False):\n        \"\"\"\n        get the query manager for the given language and fileName\n\n        Args:\n            lang(str): the language of the queries to extract\n            name(str): the name of the manager containing the query specifications\n            debug(bool): if True set debugging on\n        \"\"\"\n        qYamlFileName = f\"{name}.yaml\"\n        for qYamlFile in YamlPath.getPaths(qYamlFileName):\n            if os.path.isfile(qYamlFile):\n                qm = QueryManager(lang=lang, debug=debug, queriesPath=qYamlFile)\n                return qm\n        return None\n\n    def generateSparqlQuery(\n        self,\n        genMap: dict,\n        listSeparator: str = \"\u21f9\",\n        naive: bool = True,\n        lang: str = \"en\",\n    ) -&gt; str:\n        \"\"\"\n        generate a SPARQL Query\n\n        Args:\n            genMap(dict): a dictionary of generation items aggregates/ignores/labels\n            listSeparator(str): the symbole to use as a list separator for GROUP_CONCAT\n            naive(bool): if True - generate a naive straight forward SPARQL query\n                if False generate a proper truly tabular aggregate query\n            lang(str): the language to generate for\n\n        Returns:\n            str: the generated SPARQL Query\n        \"\"\"\n        # The Wikidata item to generate the query for\n        item = self.item\n        # the name of this script\n        script = Path(__file__).name\n        # the mode of generation\n        naiveText = \"naive\" if naive else \"aggregate\"\n        # start with th preamble and PREFIX section\n        # select the item and it's label\n        sparqlQuery = f\"\"\"# truly tabular {naiveText} query for \n# {item.qid}:{item.qlabel}\n# generated by {script} version {Version.version} on {self.isodate}\n{Prefixes.getPrefixes()}\nSELECT ?{item.itemVarname} ?{item.labelVarname}\"\"\"\n        # loop over all properties\n        for wdProp in self.properties.values():\n            if naive:\n                sparqlQuery += f\"\\n  ?{wdProp.valueVarname}\"\n            else:\n                if wdProp.pid in genMap:\n                    genList = genMap[wdProp.pid]\n                    for aggregate in genList:\n                        if not aggregate in [\"ignore\", \"label\"]:\n                            distinct = \"\"\n                            if aggregate == \"list\":\n                                aggregateFunc = \"GROUP_CONCAT\"\n                                aggregateParam = f';SEPARATOR=\"{listSeparator}\"'\n                                distinct = \"DISTINCT \"\n                            else:\n                                if aggregate == \"count\":\n                                    distinct = \"DISTINCT \"\n                                aggregateFunc = aggregate.upper()\n                                aggregateParam = \"\"\n                            sparqlQuery += f\"\\n  ({aggregateFunc} ({distinct}?{wdProp.valueVarname}{aggregateParam}) AS ?{wdProp.valueVarname}_{aggregate})\"\n                        elif aggregate == \"label\":\n                            sparqlQuery += f\"\\n  ?{wdProp.labelVarname}\"\n                        elif aggregate == \"ignore\" and not \"label\" in genList:\n                            sparqlQuery += f\"\\n  ?{wdProp.valueVarname}\"\n        sparqlQuery += f\"\"\"\nWHERE {{\n  # instanceof {item.qid}:{item.qlabel}\n  ?{item.itemVarname} {self.search_predicate} wd:{item.qid}.\n  # label\n  ?{item.itemVarname} rdfs:label ?{item.labelVarname}.  \n  FILTER (LANG(?{item.labelVarname}) = \"{lang}\").\n\"\"\"\n        for wdProp in self.properties.values():\n            sparqlQuery += f\"\"\"  # {wdProp}\n  OPTIONAL {{ \n    ?{item.itemVarname} wdt:{wdProp.pid} ?{wdProp.valueVarname}. \"\"\"\n            if wdProp.pid in genMap:\n                genList = genMap[wdProp.pid]\n                if \"label\" in genList:\n                    sparqlQuery += f\"\"\"\\n    ?{wdProp.valueVarname} rdfs:label ?{wdProp.labelVarname}.\"\"\"\n                    sparqlQuery += (\n                        f\"\"\"\\n    FILTER (LANG(?{wdProp.labelVarname}) = \"{lang}\").\"\"\"\n                    )\n            sparqlQuery += \"\\n  }\\n\"\n        # close where Clause\n        sparqlQuery += \"\"\"}\\n\"\"\"\n        # optionally add Aggregate\n        if not naive:\n            sparqlQuery += f\"\"\"GROUP BY\n  ?{item.itemVarname} \n  ?{item.labelVarname}\n\"\"\"\n            for wdProp in self.properties.values():\n                if wdProp.pid in genMap:\n                    genList = genMap[wdProp.pid]\n                    if \"label\" in genList:\n                        sparqlQuery += f\"\\n  ?{wdProp.labelVarname}\"\n                    if \"ignore\" in genList and not \"label\" in genList:\n                        sparqlQuery += f\"\\n  ?{wdProp.valueVarname}\"\n            havingCount = 0\n            havingDelim = \"   \"\n            for wdProp in self.properties.values():\n                if wdProp.pid in genMap:\n                    genList = genMap[wdProp.pid]\n                    if \"ignore\" in genList:\n                        havingCount += 1\n                        if havingCount == 1:\n                            sparqlQuery += f\"\\nHAVING (\"\n\n                        sparqlQuery += (\n                            f\"\\n  {havingDelim}COUNT(?{wdProp.valueVarname})&lt;=1\"\n                        )\n                        havingDelim = \"&amp;&amp; \"\n            if havingCount &gt; 0:\n                sparqlQuery += f\"\\n)\"\n        return sparqlQuery\n\n    def mostFrequentPropertiesQuery(self, whereClause: str = None, minCount: int = 0):\n        \"\"\"\n        get the most frequently used properties\n\n        Args:\n            whereClause(str): an extra WhereClause to use\n        \"\"\"\n        if whereClause is None:\n            whereClause = f\"?item {self.search_predicate} wd:{self.itemQid}\"\n            if self.endpointConf.database != \"qlever\":\n                whereClause += \";?p ?id\"\n        whereClause += \".\"\n        minCountFilter = \"\"\n        if minCount &gt; 0:\n            minCountFilter = f\"\\n  FILTER(?count &gt;{minCount}).\"\n        itemText = self.getItemText()\n        sparqlQuery = f\"\"\"# get the most frequently used properties for\n# {itemText}\n{Prefixes.getPrefixes()}\nSELECT ?prop ?propLabel ?wbType ?count WHERE {{\n  {{\"\"\"\n        if self.endpointConf.database == \"qlever\":\n            sparqlQuery += f\"\"\"\n    SELECT ?p (COUNT(DISTINCT ?item) AS ?count) WHERE {{\"\"\"\n        else:\n            sparqlQuery += f\"\"\"\n    SELECT ?prop (COUNT(DISTINCT ?item) AS ?count) WHERE {{\"\"\"\n        if self.endpointConf.database == \"blazegraph\":\n            sparqlQuery += f\"\"\"\n      hint:Query hint:optimizer \"None\".\"\"\"\n        sparqlQuery += f\"\"\"\n      {whereClause}\"\"\"\n        if self.endpointConf.database == \"qlever\":\n            sparqlQuery += f\"\"\"  \n      ?item ql:has-predicate ?p \n    }} GROUP BY ?p\n  }}\n  ?prop wikibase:directClaim ?p.\"\"\"\n        else:\n            sparqlQuery += f\"\"\"\n      ?prop wikibase:directClaim ?p.\n    }}\n    GROUP BY ?prop ?propLabel\n  }}\"\"\"\n        sparqlQuery += f\"\"\"\n  ?prop rdfs:label ?propLabel.\n  ?prop wikibase:propertyType ?wbType.\n  FILTER(LANG(?propLabel) = \"{self.lang}\").{minCountFilter}  \n}}\nORDER BY DESC (?count)\n\"\"\"\n        title = f\"most frequently used properties for {self.item.asText(long=True)}\"\n        query = Query(\n            name=f\"mostFrequentProperties for {itemText}\",\n            query=sparqlQuery,\n            title=title,\n        )\n        return query\n\n    def noneTabularQuery(self, wdProperty: WikidataProperty, asFrequency: bool = True):\n        \"\"\"\n        get the none tabular entries for the given property\n\n        Args:\n            wdProperty(WikidataProperty): the property to analyze\n            asFrequency(bool): if true do a frequency analysis\n        \"\"\"\n        propertyLabel = wdProperty.plabel\n        propertyId = wdProperty.pid\n        # work around https://github.com/RDFLib/sparqlwrapper/issues/211\n        if \"described at\" in propertyLabel:\n            propertyLabel = propertyLabel.replace(\"described at\", \"describ'd at\")\n        sparql = f\"\"\"SELECT ?item ?itemLabel (COUNT (?value) AS ?count)\nWHERE\n{{\n  # instance of {self.item.qlabel}\n  ?item {self.search_predicate} wd:{self.itemQid}.{self.where}\n  ?item rdfs:label ?itemLabel.\n  FILTER (LANG(?itemLabel) = \"{self.lang}\").\n  # {propertyLabel}\n  ?item {wdProperty.getPredicate()} ?value.\n}} GROUP BY ?item ?itemLabel\n\"\"\"\n        if asFrequency:\n            freqDesc = \"frequencies\"\n            sparql = f\"\"\"SELECT ?count (COUNT(?count) AS ?frequency) WHERE {{{{\n{sparql}\n}}}}\nGROUP BY ?count\nORDER BY DESC (?frequency)\"\"\"\n        else:\n            freqDesc = \"records\"\n            sparql = f\"\"\"{sparql}\nHAVING (COUNT (?value) &gt; 1)\nORDER BY DESC(?count)\"\"\"\n        itemText = self.getItemText()\n        sparql = (\n            f\"\"\"# Count all {itemText} items\n# with the given {propertyLabel}({propertyId}) https://www.wikidata.org/wiki/Property:{propertyId} \n{Prefixes.getPrefixes()}\n\"\"\"\n            + sparql\n        )\n        title = f\"non tabular entries for {self.item.qlabel}/{propertyLabel}:{freqDesc}\"\n        name = f\"NonTabular {self.item.qlabel}/{propertyLabel}:{freqDesc}\"\n        query = Query(query=sparql, name=name, title=title)\n        return query\n\n    def noneTabular(self, wdProperty: WikidataProperty):\n        \"\"\"\n        get the none tabular result for the given Wikidata property\n\n        Args:\n            wdProperty(WikidataProperty): the Wikidata property\n        \"\"\"\n        query = self.noneTabularQuery(wdProperty)\n        if self.debug:\n            logging.info(query.query)\n        qlod = self.sparql.queryAsListOfDicts(query.query)\n        return qlod\n\n    def addStatsColWithPercent(\n        self, m: dict, col: str, value: Union[int, float], total: Union[int, float]\n    ):\n        \"\"\"\n        add a statistics Column\n        Args:\n            m(dict):\n            col(str): name of the column\n            value: value\n            total: total value\n        \"\"\"\n        m[col] = value\n        if total is not None and total &gt; 0:\n            m[f\"{col}%\"] = float(f\"{value/total*100:.1f}\")\n        else:\n            m[f\"{col}%\"] = None\n\n    def genWdPropertyStatistic(\n        self, wdProperty: WikidataProperty, itemCount: int, withQuery=True\n    ) -&gt; dict:\n        \"\"\"\n        generate a property Statistics Row for the given wikidata Property\n\n        Args:\n            wdProperty(WikidataProperty): the property to get the statistics for\n            itemCount(int): the total number of items to check\n            withQuery(bool): if true include the sparql query\n\n        Returns:\n            dict: a statistics row\n        \"\"\"\n        ntlod = self.noneTabular(wdProperty)\n        statsRow = {\"property\": wdProperty.plabel}\n        total = 0\n        nttotal = 0\n        maxCount = 0\n        for record in ntlod:\n            f = int(record[\"frequency\"])\n            count = int(record[\"count\"])\n            # statsRow[f\"f{count}\"]=f\n            if count &gt; 1:\n                nttotal += f\n            else:\n                statsRow[\"1\"] = f\n            if count &gt; maxCount:\n                maxCount = count\n            total += f\n        statsRow[\"maxf\"] = maxCount\n        if withQuery:\n            statsRow[\"queryf\"] = self.noneTabularQuery(wdProperty).query\n            statsRow[\"queryex\"] = self.noneTabularQuery(\n                wdProperty, asFrequency=False\n            ).query\n        self.addStatsColWithPercent(statsRow, \"total\", total, itemCount)\n        self.addStatsColWithPercent(statsRow, \"non tabular\", nttotal, total)\n        return statsRow\n\n    def genPropertyStatistics(self):\n        \"\"\"\n        generate the property Statistics\n\n        Returns:\n            generator: a generator of statistic dict rows\n        \"\"\"\n        itemCount, _itemCountQuery = self.count()\n        for wdProperty in self.properties.values():\n            statsRow = self.genWdPropertyStatistic(wdProperty, itemCount)\n            yield statsRow\n\n    def getPropertyStatistics(self):\n        \"\"\"\n        get the property Statistics\n        \"\"\"\n        itemCount, _itemCountQuery = self.count()\n        lod = [{\"property\": \"\u2211\", \"total\": itemCount, \"total%\": 100.0}]\n        for wdProperty in self.properties.values():\n            statsRow = self.genWdPropertyStatistic(wdProperty, itemCount)\n            lod.append(statsRow)\n        return lod\n</code></pre>"},{"location":"#ez_wikidata.trulytabular.TrulyTabular.__init__","title":"<code>__init__(itemQid, propertyLabels=[], propertyIds=[], search_predicate='wdt:P31', where=None, endpointConf=None, lang='en', debug=False)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>itemQid(str)</code> <p>wikidata id of the type to analyze</p> required <code>propertyLabels(list)</code> <p>a list of labels of properties to be considered</p> required <code>propertyIds(list)</code> <p>a list of ids of properties to be considered</p> required <code>search_predicate(str)</code> <p>the search predicate to use e.g. instanceof / subclass of</p> required <code>where(str)</code> <p>extra where clause for instance selection (if any)</p> required <code>endpoint(str)</code> <p>the url of the SPARQL endpoint to be used</p> required Source code in <code>ez_wikidata/trulytabular.py</code> <pre><code>def __init__(\n    self,\n    itemQid,\n    propertyLabels: list = [],\n    propertyIds: list = [],\n    search_predicate=\"wdt:P31\",\n    where: str = None,\n    endpointConf=None,\n    lang=\"en\",\n    debug=False,\n):\n    \"\"\"\n    Constructor\n\n    Args:\n        itemQid(str): wikidata id of the type to analyze\n        propertyLabels(list): a list of labels of properties to be considered\n        propertyIds(list): a list of ids of properties to be considered\n        search_predicate(str): the search predicate to use e.g. instanceof / subclass of\n        where(str): extra where clause for instance selection (if any)\n        endpoint(str): the url of the SPARQL endpoint to be used\n    \"\"\"\n    self.itemQid = itemQid\n    self.debug = debug\n    if endpointConf is None:\n        endpointConf = Endpoint.getDefault()\n    self.endpointConf = endpointConf\n    self.wpm = WikidataPropertyManager.get_instance(\n        endpoint_url=endpointConf.endpoint\n    )\n    self.sparql = SPARQL(endpointConf.endpoint, method=self.endpointConf.method)\n    self.sparql.debug = self.debug\n    self.search_predicate = search_predicate\n    self.where = f\"\\n  {where}\" if where is not None else \"\"\n    self.lang = lang\n    self.item = WikidataItem(\n        itemQid, sparql=self.sparql, lang=lang, debug=self.debug\n    )\n    self.queryManager = TrulyTabular.getQueryManager(debug=self.debug)\n    self.properties = self.wpm.get_properties_by_ids(propertyIds)\n    self.properties.update(\n        self.wpm.get_properties_by_labels(propertyLabels, lang=lang)\n    )\n    self.isodate = datetime.datetime.now().isoformat()\n    self.error = None\n</code></pre>"},{"location":"#ez_wikidata.trulytabular.TrulyTabular.__str__","title":"<code>__str__()</code>","text":"<p>Returns:</p> Name Type Description <code>str</code> <p>my text representation</p> Source code in <code>ez_wikidata/trulytabular.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    Returns:\n        str: my text representation\n    \"\"\"\n    return self.asText(long=False)\n</code></pre>"},{"location":"#ez_wikidata.trulytabular.TrulyTabular.addStatsColWithPercent","title":"<code>addStatsColWithPercent(m, col, value, total)</code>","text":"<p>add a statistics Column Args:     m(dict):     col(str): name of the column     value: value     total: total value</p> Source code in <code>ez_wikidata/trulytabular.py</code> <pre><code>def addStatsColWithPercent(\n    self, m: dict, col: str, value: Union[int, float], total: Union[int, float]\n):\n    \"\"\"\n    add a statistics Column\n    Args:\n        m(dict):\n        col(str): name of the column\n        value: value\n        total: total value\n    \"\"\"\n    m[col] = value\n    if total is not None and total &gt; 0:\n        m[f\"{col}%\"] = float(f\"{value/total*100:.1f}\")\n    else:\n        m[f\"{col}%\"] = None\n</code></pre>"},{"location":"#ez_wikidata.trulytabular.TrulyTabular.asText","title":"<code>asText(long=True)</code>","text":"<p>returns my content as a text representation</p> <p>Parameters:</p> Name Type Description Default <code>long(bool)</code> <p>True if a long format including url is wished</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>a text representation of my content</p> Source code in <code>ez_wikidata/trulytabular.py</code> <pre><code>def asText(self, long: bool = True):\n    \"\"\"\n    returns my content as a text representation\n\n    Args:\n        long(bool): True if a long format including url is wished\n\n    Returns:\n        str: a text representation of my content\n    \"\"\"\n    text = self.item.asText(long)\n    return text\n</code></pre>"},{"location":"#ez_wikidata.trulytabular.TrulyTabular.count","title":"<code>count()</code>","text":"<p>get my count</p> Source code in <code>ez_wikidata/trulytabular.py</code> <pre><code>    def count(self):\n        \"\"\"\n        get my count\n        \"\"\"\n        itemText = self.getItemText()\n        query = f\"\"\"# Count all items with the given type\n# {itemText}\n{Prefixes.getPrefixes()}\nSELECT (COUNT (DISTINCT ?item) AS ?count)\nWHERE\n{{\n  # instance of {self.item.qlabel}\n  ?item {self.search_predicate} wd:{self.item.qid}.{self.where}\n}}\"\"\"\n        try:\n            count = self.sparql.getValue(query, \"count\")\n            # workaround https://github.com/ad-freiburg/qlever/issues/717\n            count = int(count)\n        except Exception as ex:\n            self.error = ex\n            count = None\n\n        return count, query\n</code></pre>"},{"location":"#ez_wikidata.trulytabular.TrulyTabular.genPropertyStatistics","title":"<code>genPropertyStatistics()</code>","text":"<p>generate the property Statistics</p> <p>Returns:</p> Name Type Description <code>generator</code> <p>a generator of statistic dict rows</p> Source code in <code>ez_wikidata/trulytabular.py</code> <pre><code>def genPropertyStatistics(self):\n    \"\"\"\n    generate the property Statistics\n\n    Returns:\n        generator: a generator of statistic dict rows\n    \"\"\"\n    itemCount, _itemCountQuery = self.count()\n    for wdProperty in self.properties.values():\n        statsRow = self.genWdPropertyStatistic(wdProperty, itemCount)\n        yield statsRow\n</code></pre>"},{"location":"#ez_wikidata.trulytabular.TrulyTabular.genWdPropertyStatistic","title":"<code>genWdPropertyStatistic(wdProperty, itemCount, withQuery=True)</code>","text":"<p>generate a property Statistics Row for the given wikidata Property</p> <p>Parameters:</p> Name Type Description Default <code>wdProperty(WikidataProperty)</code> <p>the property to get the statistics for</p> required <code>itemCount(int)</code> <p>the total number of items to check</p> required <code>withQuery(bool)</code> <p>if true include the sparql query</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>a statistics row</p> Source code in <code>ez_wikidata/trulytabular.py</code> <pre><code>def genWdPropertyStatistic(\n    self, wdProperty: WikidataProperty, itemCount: int, withQuery=True\n) -&gt; dict:\n    \"\"\"\n    generate a property Statistics Row for the given wikidata Property\n\n    Args:\n        wdProperty(WikidataProperty): the property to get the statistics for\n        itemCount(int): the total number of items to check\n        withQuery(bool): if true include the sparql query\n\n    Returns:\n        dict: a statistics row\n    \"\"\"\n    ntlod = self.noneTabular(wdProperty)\n    statsRow = {\"property\": wdProperty.plabel}\n    total = 0\n    nttotal = 0\n    maxCount = 0\n    for record in ntlod:\n        f = int(record[\"frequency\"])\n        count = int(record[\"count\"])\n        # statsRow[f\"f{count}\"]=f\n        if count &gt; 1:\n            nttotal += f\n        else:\n            statsRow[\"1\"] = f\n        if count &gt; maxCount:\n            maxCount = count\n        total += f\n    statsRow[\"maxf\"] = maxCount\n    if withQuery:\n        statsRow[\"queryf\"] = self.noneTabularQuery(wdProperty).query\n        statsRow[\"queryex\"] = self.noneTabularQuery(\n            wdProperty, asFrequency=False\n        ).query\n    self.addStatsColWithPercent(statsRow, \"total\", total, itemCount)\n    self.addStatsColWithPercent(statsRow, \"non tabular\", nttotal, total)\n    return statsRow\n</code></pre>"},{"location":"#ez_wikidata.trulytabular.TrulyTabular.generateSparqlQuery","title":"<code>generateSparqlQuery(genMap, listSeparator='\u21f9', naive=True, lang='en')</code>","text":"<p>generate a SPARQL Query</p> <p>Parameters:</p> Name Type Description Default <code>genMap(dict)</code> <p>a dictionary of generation items aggregates/ignores/labels</p> required <code>listSeparator(str)</code> <p>the symbole to use as a list separator for GROUP_CONCAT</p> required <code>naive(bool)</code> <p>if True - generate a naive straight forward SPARQL query if False generate a proper truly tabular aggregate query</p> required <code>lang(str)</code> <p>the language to generate for</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the generated SPARQL Query</p> Source code in <code>ez_wikidata/trulytabular.py</code> <pre><code>    def generateSparqlQuery(\n        self,\n        genMap: dict,\n        listSeparator: str = \"\u21f9\",\n        naive: bool = True,\n        lang: str = \"en\",\n    ) -&gt; str:\n        \"\"\"\n        generate a SPARQL Query\n\n        Args:\n            genMap(dict): a dictionary of generation items aggregates/ignores/labels\n            listSeparator(str): the symbole to use as a list separator for GROUP_CONCAT\n            naive(bool): if True - generate a naive straight forward SPARQL query\n                if False generate a proper truly tabular aggregate query\n            lang(str): the language to generate for\n\n        Returns:\n            str: the generated SPARQL Query\n        \"\"\"\n        # The Wikidata item to generate the query for\n        item = self.item\n        # the name of this script\n        script = Path(__file__).name\n        # the mode of generation\n        naiveText = \"naive\" if naive else \"aggregate\"\n        # start with th preamble and PREFIX section\n        # select the item and it's label\n        sparqlQuery = f\"\"\"# truly tabular {naiveText} query for \n# {item.qid}:{item.qlabel}\n# generated by {script} version {Version.version} on {self.isodate}\n{Prefixes.getPrefixes()}\nSELECT ?{item.itemVarname} ?{item.labelVarname}\"\"\"\n        # loop over all properties\n        for wdProp in self.properties.values():\n            if naive:\n                sparqlQuery += f\"\\n  ?{wdProp.valueVarname}\"\n            else:\n                if wdProp.pid in genMap:\n                    genList = genMap[wdProp.pid]\n                    for aggregate in genList:\n                        if not aggregate in [\"ignore\", \"label\"]:\n                            distinct = \"\"\n                            if aggregate == \"list\":\n                                aggregateFunc = \"GROUP_CONCAT\"\n                                aggregateParam = f';SEPARATOR=\"{listSeparator}\"'\n                                distinct = \"DISTINCT \"\n                            else:\n                                if aggregate == \"count\":\n                                    distinct = \"DISTINCT \"\n                                aggregateFunc = aggregate.upper()\n                                aggregateParam = \"\"\n                            sparqlQuery += f\"\\n  ({aggregateFunc} ({distinct}?{wdProp.valueVarname}{aggregateParam}) AS ?{wdProp.valueVarname}_{aggregate})\"\n                        elif aggregate == \"label\":\n                            sparqlQuery += f\"\\n  ?{wdProp.labelVarname}\"\n                        elif aggregate == \"ignore\" and not \"label\" in genList:\n                            sparqlQuery += f\"\\n  ?{wdProp.valueVarname}\"\n        sparqlQuery += f\"\"\"\nWHERE {{\n  # instanceof {item.qid}:{item.qlabel}\n  ?{item.itemVarname} {self.search_predicate} wd:{item.qid}.\n  # label\n  ?{item.itemVarname} rdfs:label ?{item.labelVarname}.  \n  FILTER (LANG(?{item.labelVarname}) = \"{lang}\").\n\"\"\"\n        for wdProp in self.properties.values():\n            sparqlQuery += f\"\"\"  # {wdProp}\n  OPTIONAL {{ \n    ?{item.itemVarname} wdt:{wdProp.pid} ?{wdProp.valueVarname}. \"\"\"\n            if wdProp.pid in genMap:\n                genList = genMap[wdProp.pid]\n                if \"label\" in genList:\n                    sparqlQuery += f\"\"\"\\n    ?{wdProp.valueVarname} rdfs:label ?{wdProp.labelVarname}.\"\"\"\n                    sparqlQuery += (\n                        f\"\"\"\\n    FILTER (LANG(?{wdProp.labelVarname}) = \"{lang}\").\"\"\"\n                    )\n            sparqlQuery += \"\\n  }\\n\"\n        # close where Clause\n        sparqlQuery += \"\"\"}\\n\"\"\"\n        # optionally add Aggregate\n        if not naive:\n            sparqlQuery += f\"\"\"GROUP BY\n  ?{item.itemVarname} \n  ?{item.labelVarname}\n\"\"\"\n            for wdProp in self.properties.values():\n                if wdProp.pid in genMap:\n                    genList = genMap[wdProp.pid]\n                    if \"label\" in genList:\n                        sparqlQuery += f\"\\n  ?{wdProp.labelVarname}\"\n                    if \"ignore\" in genList and not \"label\" in genList:\n                        sparqlQuery += f\"\\n  ?{wdProp.valueVarname}\"\n            havingCount = 0\n            havingDelim = \"   \"\n            for wdProp in self.properties.values():\n                if wdProp.pid in genMap:\n                    genList = genMap[wdProp.pid]\n                    if \"ignore\" in genList:\n                        havingCount += 1\n                        if havingCount == 1:\n                            sparqlQuery += f\"\\nHAVING (\"\n\n                        sparqlQuery += (\n                            f\"\\n  {havingDelim}COUNT(?{wdProp.valueVarname})&lt;=1\"\n                        )\n                        havingDelim = \"&amp;&amp; \"\n            if havingCount &gt; 0:\n                sparqlQuery += f\"\\n)\"\n        return sparqlQuery\n</code></pre>"},{"location":"#ez_wikidata.trulytabular.TrulyTabular.getPropertyStatistics","title":"<code>getPropertyStatistics()</code>","text":"<p>get the property Statistics</p> Source code in <code>ez_wikidata/trulytabular.py</code> <pre><code>def getPropertyStatistics(self):\n    \"\"\"\n    get the property Statistics\n    \"\"\"\n    itemCount, _itemCountQuery = self.count()\n    lod = [{\"property\": \"\u2211\", \"total\": itemCount, \"total%\": 100.0}]\n    for wdProperty in self.properties.values():\n        statsRow = self.genWdPropertyStatistic(wdProperty, itemCount)\n        lod.append(statsRow)\n    return lod\n</code></pre>"},{"location":"#ez_wikidata.trulytabular.TrulyTabular.getQueryManager","title":"<code>getQueryManager(lang='sparql', name='trulytabular', debug=False)</code>  <code>classmethod</code>","text":"<p>get the query manager for the given language and fileName</p> <p>Parameters:</p> Name Type Description Default <code>lang(str)</code> <p>the language of the queries to extract</p> required <code>name(str)</code> <p>the name of the manager containing the query specifications</p> required <code>debug(bool)</code> <p>if True set debugging on</p> required Source code in <code>ez_wikidata/trulytabular.py</code> <pre><code>@classmethod\ndef getQueryManager(cls, lang=\"sparql\", name=\"trulytabular\", debug=False):\n    \"\"\"\n    get the query manager for the given language and fileName\n\n    Args:\n        lang(str): the language of the queries to extract\n        name(str): the name of the manager containing the query specifications\n        debug(bool): if True set debugging on\n    \"\"\"\n    qYamlFileName = f\"{name}.yaml\"\n    for qYamlFile in YamlPath.getPaths(qYamlFileName):\n        if os.path.isfile(qYamlFile):\n            qm = QueryManager(lang=lang, debug=debug, queriesPath=qYamlFile)\n            return qm\n    return None\n</code></pre>"},{"location":"#ez_wikidata.trulytabular.TrulyTabular.mostFrequentPropertiesQuery","title":"<code>mostFrequentPropertiesQuery(whereClause=None, minCount=0)</code>","text":"<p>get the most frequently used properties</p> <p>Parameters:</p> Name Type Description Default <code>whereClause(str)</code> <p>an extra WhereClause to use</p> required Source code in <code>ez_wikidata/trulytabular.py</code> <pre><code>    def mostFrequentPropertiesQuery(self, whereClause: str = None, minCount: int = 0):\n        \"\"\"\n        get the most frequently used properties\n\n        Args:\n            whereClause(str): an extra WhereClause to use\n        \"\"\"\n        if whereClause is None:\n            whereClause = f\"?item {self.search_predicate} wd:{self.itemQid}\"\n            if self.endpointConf.database != \"qlever\":\n                whereClause += \";?p ?id\"\n        whereClause += \".\"\n        minCountFilter = \"\"\n        if minCount &gt; 0:\n            minCountFilter = f\"\\n  FILTER(?count &gt;{minCount}).\"\n        itemText = self.getItemText()\n        sparqlQuery = f\"\"\"# get the most frequently used properties for\n# {itemText}\n{Prefixes.getPrefixes()}\nSELECT ?prop ?propLabel ?wbType ?count WHERE {{\n  {{\"\"\"\n        if self.endpointConf.database == \"qlever\":\n            sparqlQuery += f\"\"\"\n    SELECT ?p (COUNT(DISTINCT ?item) AS ?count) WHERE {{\"\"\"\n        else:\n            sparqlQuery += f\"\"\"\n    SELECT ?prop (COUNT(DISTINCT ?item) AS ?count) WHERE {{\"\"\"\n        if self.endpointConf.database == \"blazegraph\":\n            sparqlQuery += f\"\"\"\n      hint:Query hint:optimizer \"None\".\"\"\"\n        sparqlQuery += f\"\"\"\n      {whereClause}\"\"\"\n        if self.endpointConf.database == \"qlever\":\n            sparqlQuery += f\"\"\"  \n      ?item ql:has-predicate ?p \n    }} GROUP BY ?p\n  }}\n  ?prop wikibase:directClaim ?p.\"\"\"\n        else:\n            sparqlQuery += f\"\"\"\n      ?prop wikibase:directClaim ?p.\n    }}\n    GROUP BY ?prop ?propLabel\n  }}\"\"\"\n        sparqlQuery += f\"\"\"\n  ?prop rdfs:label ?propLabel.\n  ?prop wikibase:propertyType ?wbType.\n  FILTER(LANG(?propLabel) = \"{self.lang}\").{minCountFilter}  \n}}\nORDER BY DESC (?count)\n\"\"\"\n        title = f\"most frequently used properties for {self.item.asText(long=True)}\"\n        query = Query(\n            name=f\"mostFrequentProperties for {itemText}\",\n            query=sparqlQuery,\n            title=title,\n        )\n        return query\n</code></pre>"},{"location":"#ez_wikidata.trulytabular.TrulyTabular.noneTabular","title":"<code>noneTabular(wdProperty)</code>","text":"<p>get the none tabular result for the given Wikidata property</p> <p>Parameters:</p> Name Type Description Default <code>wdProperty(WikidataProperty)</code> <p>the Wikidata property</p> required Source code in <code>ez_wikidata/trulytabular.py</code> <pre><code>def noneTabular(self, wdProperty: WikidataProperty):\n    \"\"\"\n    get the none tabular result for the given Wikidata property\n\n    Args:\n        wdProperty(WikidataProperty): the Wikidata property\n    \"\"\"\n    query = self.noneTabularQuery(wdProperty)\n    if self.debug:\n        logging.info(query.query)\n    qlod = self.sparql.queryAsListOfDicts(query.query)\n    return qlod\n</code></pre>"},{"location":"#ez_wikidata.trulytabular.TrulyTabular.noneTabularQuery","title":"<code>noneTabularQuery(wdProperty, asFrequency=True)</code>","text":"<p>get the none tabular entries for the given property</p> <p>Parameters:</p> Name Type Description Default <code>wdProperty(WikidataProperty)</code> <p>the property to analyze</p> required <code>asFrequency(bool)</code> <p>if true do a frequency analysis</p> required Source code in <code>ez_wikidata/trulytabular.py</code> <pre><code>    def noneTabularQuery(self, wdProperty: WikidataProperty, asFrequency: bool = True):\n        \"\"\"\n        get the none tabular entries for the given property\n\n        Args:\n            wdProperty(WikidataProperty): the property to analyze\n            asFrequency(bool): if true do a frequency analysis\n        \"\"\"\n        propertyLabel = wdProperty.plabel\n        propertyId = wdProperty.pid\n        # work around https://github.com/RDFLib/sparqlwrapper/issues/211\n        if \"described at\" in propertyLabel:\n            propertyLabel = propertyLabel.replace(\"described at\", \"describ'd at\")\n        sparql = f\"\"\"SELECT ?item ?itemLabel (COUNT (?value) AS ?count)\nWHERE\n{{\n  # instance of {self.item.qlabel}\n  ?item {self.search_predicate} wd:{self.itemQid}.{self.where}\n  ?item rdfs:label ?itemLabel.\n  FILTER (LANG(?itemLabel) = \"{self.lang}\").\n  # {propertyLabel}\n  ?item {wdProperty.getPredicate()} ?value.\n}} GROUP BY ?item ?itemLabel\n\"\"\"\n        if asFrequency:\n            freqDesc = \"frequencies\"\n            sparql = f\"\"\"SELECT ?count (COUNT(?count) AS ?frequency) WHERE {{{{\n{sparql}\n}}}}\nGROUP BY ?count\nORDER BY DESC (?frequency)\"\"\"\n        else:\n            freqDesc = \"records\"\n            sparql = f\"\"\"{sparql}\nHAVING (COUNT (?value) &gt; 1)\nORDER BY DESC(?count)\"\"\"\n        itemText = self.getItemText()\n        sparql = (\n            f\"\"\"# Count all {itemText} items\n# with the given {propertyLabel}({propertyId}) https://www.wikidata.org/wiki/Property:{propertyId} \n{Prefixes.getPrefixes()}\n\"\"\"\n            + sparql\n        )\n        title = f\"non tabular entries for {self.item.qlabel}/{propertyLabel}:{freqDesc}\"\n        name = f\"NonTabular {self.item.qlabel}/{propertyLabel}:{freqDesc}\"\n        query = Query(query=sparql, name=name, title=title)\n        return query\n</code></pre>"},{"location":"#ez_wikidata.version","title":"<code>version</code>","text":"<p>Created on 2024-03-01</p> <p>@author: wf</p>"},{"location":"#ez_wikidata.version.Version","title":"<code>Version</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for easy wikidata access</p> Source code in <code>ez_wikidata/version.py</code> <pre><code>@dataclass\nclass Version(object):\n    \"\"\"\n    Version handling for easy wikidata access\n    \"\"\"\n\n    name = \"py_ez_wikidata\"\n    version = ez_wikidata.__version__\n    date = \"2024-03-01\"\n    updated = \"2024-08-09\"\n    description = \"Mapping for Wikidata allows creation of wikidata entries from dicts\"\n\n    authors = \"Tim Holzheim, Wolfgang Fahl\"\n\n    doc_url = \"https://wiki.bitplan.com/index.php/Py_ez_wikidata\"\n    chat_url = \"https://github.com/WolfgangFahl/py_ez_wikidata/discussions\"\n    cm_url = \"https://github.com/WolfgangFahl/py_ez_wikidata\"\n\n    license = f\"\"\"Copyright 2024 contributors. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n    longDescription = f\"\"\"{name} version {version}\n{description}\n\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"},{"location":"#ez_wikidata.wbquery","title":"<code>wbquery</code>","text":"<p>Created on 2022-04-30</p> <p>@author: wf</p>"},{"location":"#ez_wikidata.wbquery.WikibaseQuery","title":"<code>WikibaseQuery</code>","text":"<p>               Bases: <code>object</code></p> <p>a Query for Wikibase</p> Source code in <code>ez_wikidata/wbquery.py</code> <pre><code>class WikibaseQuery(object):\n    \"\"\"\n    a Query for Wikibase\n    \"\"\"\n\n    def __init__(\n        self, entity: str, wpm: WikidataPropertyManager = None, debug: bool = False\n    ):\n        \"\"\"\n        Constructor\n\n        Args:\n            entity(str): the entity this query represents\n            debug(bool): if True switch on debugging\n        \"\"\"\n        self.debug = debug\n        self.entity = entity\n        if wpm is None:\n            wpm = WikidataPropertyManager.get_instance()\n        self.wpm = wpm\n        self.propertiesByName = {}\n        self.propertiesById = {}\n        self.propertiesByVarname = {}\n        self.propertiesByColumn = {}\n        self.rows = []\n\n    def get_property_mappings(self) -&gt; List[PropertyMapping]:\n        \"\"\"\n        Get the property mappings as PropertyMapping list\n\n        Returns:\n            List[PropertyMapping]: list of PropertyMappings\n        \"\"\"\n        prop_maps = self.wpm.get_mappings_for_records(self.propertiesByColumn)\n        return prop_maps\n\n    def get_item_mapping(self) -&gt; PropertyMapping:\n        \"\"\"\n        Get the mapping that describes the wikidata entity item\n        \"\"\"\n        return PropertyMapping.get_item_mapping(self.get_property_mappings())\n\n    def addPropertyFromDescriptionRow(self, row):\n        \"\"\"\n        add a property from the given row\n\n        Args:\n            row(dict): the row to add\n        \"\"\"\n        self.rows.append(row)\n        propName = row[\"PropertyName\"]\n        propId = row[\"PropertyId\"]\n        column = row[\"Column\"]\n        # properties might contain blank - replace for SPARQL variable names\n        propVarname = row.get(\"PropVarname\", propName)\n        propVarname = propVarname.replace(\" \", \"_\")\n        propVarname = propVarname.replace(\"-\", \"_\")\n        row[\"PropVarname\"] = propVarname\n        # set the values of the lookups\n        self.propertiesByName[propName] = row\n        self.propertiesByColumn[column] = row\n        self.propertiesById[propId] = row\n        self.propertiesByVarname[propVarname] = row\n\n    def getColumnTypeAndVarname(self, propName: str) -&gt; (str, str, str):\n        \"\"\"\n        get a signature tuple consisting of columnName, propertType and SPARQL variable Name for the given property Name\n\n        Args:\n            propName(str): the name of the property\n\n        Raises:\n            Exception: if property name is not known\n\n        Returns:\n            column,propType,varName tupel\n        \"\"\"\n        if propName in self.propertiesByName:\n            propRow = self.propertiesByName[propName]\n            column = propRow[\"Column\"]\n            propType = propRow[\"Type\"]\n            varName = propRow[\"PropVarname\"]\n            if propType == \"item\" and varName in [None, \"\"]:\n                varName = \"item\"\n        else:\n            raise Exception(\n                f\"unknown property name {propName} for entity {self.entity}\"\n            )\n        return column, propType, varName\n\n    def inFilter(\n        self, values: list, propName: str = \"short_name\", lang: str = \"en\"\n    ) -&gt; str:\n        \"\"\"\n        create a SPARQL IN filter clause\n\n        Args:\n            values(list): the list of values to filter for\n            propName(str): the property name to filter with\n            lang(str): the language to apply\n        \"\"\"\n        filterClause = f\"\\n  FILTER(?{propName} IN(\"\n        delim = \"\"\n        for value in values:\n            filterClause += f\"{delim}\\n    '{value}'@{lang}\"\n            delim = \",\"\n        filterClause += \"\\n  )).\"\n        return filterClause\n\n    def getValuesClause(\n        self,\n        values: list,\n        propVarname: str = \"short_name\",\n        propType: str = \"text\",\n        lang: str = None,\n        ignoreEmpty: bool = True,\n        wbPrefix: str = \"http://www.wikidata.org/entity/\",\n    ):\n        \"\"\"\n        create a SPARQL Values clause\n\n        Args:\n            values(list): the list of values to create values for\n            propVarname(str): the property variable name to assign the values for\n            propType:\n            lang: language of labels to query\n            ignoreEmpty(bool): ignore empty values if True\n            wbPrefix(str): a wikibase/wikidata prefix to be removed for items values\n        Returns:\n            str: the SPARQL values clause\n        \"\"\"\n        valuesClause = f\"\\n  VALUES(?{propVarname}) {{\"\n        if lang is not None and propType == \"text\":\n            lang = f\"@{lang}\"\n        else:\n            lang = \"\"\n        for value in values:\n            if value or not ignoreEmpty:\n                if propType in [\"item\", \"itemid\", \"\", None]:\n                    if value and value.startswith(wbPrefix):\n                        value = value.replace(wbPrefix, \"\")\n                    valuesClause += f\"\\n   ( wd:{value} )\"\n                else:\n                    if isinstance(value, str):\n                        # escape single quotes\n                        value = value.replace(\"'\", \"\\\\'\")\n                        valuesClause += f\"\\n  ( '{value}'{lang} )\"\n                    else:\n                        valuesClause += f\"\\n  ( {str(value)} )\"\n        valuesClause += \"\\n  }.\"\n        return valuesClause\n\n    def asSparql(\n        self,\n        filterClause: str = None,\n        orderClause: str = None,\n        pk: str = None,\n        lang: str = \"en\",\n    ) -&gt; str:\n        \"\"\"\n        get the sparqlQuery for this query optionally applying a filterClause\n\n        Args:\n            filterClause(str): a filter to be applied (if any)\n            orderClause(str): an orderClause to be applied (if any)\n            pk(str): primaryKey (if any)\n            lang(str): the language to be used for labels\n        \"\"\"\n        item_mapping = self.get_item_mapping()\n        item_varname = item_mapping.varname\n        sparql = f\"\"\"# \n# get {self.entity} records \n#  \nPREFIX pq: &lt;http://www.wikidata.org/prop/qualifier/&gt;\nPREFIX p: &lt;http://www.wikidata.org/prop/&gt;\nPREFIX schema: &lt;http://schema.org/&gt;\nPREFIX wd: &lt;http://www.wikidata.org/entity/&gt;\nPREFIX wdt: &lt;http://www.wikidata.org/prop/direct/&gt;\nPREFIX wikibase: &lt;http://wikiba.se/ontology#&gt;\nPREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\nSELECT ?{item_varname} ?{item_varname}Label ?{item_varname}Description\n\"\"\"\n        for prop_map in self.get_property_mappings():\n            if prop_map.is_item_itself():\n                continue\n            if not prop_map.value and prop_map.varname:\n                property_selections = f\"\\n  ?{prop_map.varname}\"\n                if prop_map.property_type_enum is WdDatatype.itemid:\n                    # items will automatically fetch labels\n                    property_selections += f\" ?{prop_map.varname}Label\"\n                elif prop_map.property_type_enum is WdDatatype.extid:\n                    # extid' will automatically fetch formatted URIs\n                    property_selections += f\" ?{prop_map.varname}Url\"\n                sparql += property_selections\n        query_item_label = f\"\"\"?{item_varname} rdfs:label ?{item_varname}Label. FILTER(LANG(?{item_varname}Label) = \"{lang}\")\"\"\"\n        query_item_desc = f\"\"\"?{item_varname} schema:description ?{item_varname}Description. FILTER(LANG(?{item_varname}Description) = \"{lang}\")\"\"\"\n        sparql += f\"\"\"\\nWHERE {{\n    {query_item_label}\n    OPTIONAL {{\n        {query_item_desc}\n    }}\n\"\"\"\n        for prop_map in self.get_property_mappings():\n            if prop_map.propertyId in [None, \"\"]:\n                continue\n            if prop_map.value:\n                # value predefined for property\n                sparql += f\"\\n  ?{item_varname} wdt:{prop_map.propertyId} wd:{prop_map.value}.\"\n            else:\n                if prop_map.varname:\n                    # primary keys are not optional\n                    optional = pk is None or not prop_map.propertyName == pk\n                    if optional:\n                        sparql += \"\\n  OPTIONAL {\"\n                    sparql += f\"\\n    ?{item_varname} wdt:{prop_map.propertyId} ?{prop_map.varname}.\"\n                    if prop_map.property_type_enum is WdDatatype.itemid:\n                        # also query label of the qid with language lang\n                        sparql += f\"\\n    ?{prop_map.varname} rdfs:label ?{prop_map.varname}Label.\"\n                        sparql += f\"\"\"\\n    FILTER(LANG(?{prop_map.varname}Label) = \"{lang}\")\"\"\"\n                    elif prop_map.property_type_enum is WdDatatype.extid:\n                        # ToDo: decision to make see https://github.com/WolfgangFahl/PyGenericSpreadSheet/issues/15\n                        sparql += f\"\\n    wd:{prop_map.propertyId} wdt:P1630 ?{prop_map.varname}FormatterUrl.\"\n                        sparql += f\"\\n    BIND(IRI(REPLACE(?{prop_map.varname}, '^(.+)$', ?{prop_map.varname}FormatterUrl)) AS ?{prop_map.varname}Url).\"\n                    if optional:\n                        sparql += \"\\n  }\"\n        if filterClause is not None:\n            sparql += f\"\\n{filterClause}\"\n        sparql += \"\\n}\"\n        if orderClause is not None:\n            sparql += f\"\\n{orderClause}\"\n        return sparql\n\n    @classmethod\n    def ofMapRows(\n        cls, entityMapRows: list, debug: bool = False\n    ) -&gt; Dict[str, \"WikibaseQuery\"]:\n        \"\"\"\n        create a dict of wikibaseQueries from the given entityMap list of dicts\n\n        Args:\n            entityMapRows(list): a list of dict with row descriptions\n            debug(bool): if True switch on debugging\n        \"\"\"\n        queries = {}\n        entityMapDict = {}\n        for row in entityMapRows:\n            if \"Entity\" in row:\n                entity = row[\"Entity\"]\n                if not entity in entityMapDict:\n                    entityMapDict[entity] = {}\n                entityRows = entityMapDict[entity]\n                if \"PropertyName\" in row:\n                    propertyName = row[\"PropertyName\"]\n                    entityRows[propertyName] = row\n        if debug:\n            pprint.pprint(entityMapDict)\n        for entity in entityMapDict:\n            wbQuery = WikibaseQuery.ofEntityMap(entity, entityMapDict[entity])\n            queries[entity] = wbQuery\n        return queries\n\n    @classmethod\n    def ofEntityMap(cls, entity: str, entityMap: dict) -&gt; \"WikibaseQuery\":\n        \"\"\"\n        create a WikibaseQuery for the given entity and entityMap\n\n        Args:\n            entity(str): the entity name\n            entityMap(dict): the entity property descriptions\n        Returns:\n            WikibaseQuery\n        \"\"\"\n        wbQuery = WikibaseQuery(entity)\n        for row in entityMap.values():\n            wbQuery.addPropertyFromDescriptionRow(row)\n        return wbQuery\n</code></pre>"},{"location":"#ez_wikidata.wbquery.WikibaseQuery.__init__","title":"<code>__init__(entity, wpm=None, debug=False)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>entity(str)</code> <p>the entity this query represents</p> required <code>debug(bool)</code> <p>if True switch on debugging</p> required Source code in <code>ez_wikidata/wbquery.py</code> <pre><code>def __init__(\n    self, entity: str, wpm: WikidataPropertyManager = None, debug: bool = False\n):\n    \"\"\"\n    Constructor\n\n    Args:\n        entity(str): the entity this query represents\n        debug(bool): if True switch on debugging\n    \"\"\"\n    self.debug = debug\n    self.entity = entity\n    if wpm is None:\n        wpm = WikidataPropertyManager.get_instance()\n    self.wpm = wpm\n    self.propertiesByName = {}\n    self.propertiesById = {}\n    self.propertiesByVarname = {}\n    self.propertiesByColumn = {}\n    self.rows = []\n</code></pre>"},{"location":"#ez_wikidata.wbquery.WikibaseQuery.addPropertyFromDescriptionRow","title":"<code>addPropertyFromDescriptionRow(row)</code>","text":"<p>add a property from the given row</p> <p>Parameters:</p> Name Type Description Default <code>row(dict)</code> <p>the row to add</p> required Source code in <code>ez_wikidata/wbquery.py</code> <pre><code>def addPropertyFromDescriptionRow(self, row):\n    \"\"\"\n    add a property from the given row\n\n    Args:\n        row(dict): the row to add\n    \"\"\"\n    self.rows.append(row)\n    propName = row[\"PropertyName\"]\n    propId = row[\"PropertyId\"]\n    column = row[\"Column\"]\n    # properties might contain blank - replace for SPARQL variable names\n    propVarname = row.get(\"PropVarname\", propName)\n    propVarname = propVarname.replace(\" \", \"_\")\n    propVarname = propVarname.replace(\"-\", \"_\")\n    row[\"PropVarname\"] = propVarname\n    # set the values of the lookups\n    self.propertiesByName[propName] = row\n    self.propertiesByColumn[column] = row\n    self.propertiesById[propId] = row\n    self.propertiesByVarname[propVarname] = row\n</code></pre>"},{"location":"#ez_wikidata.wbquery.WikibaseQuery.asSparql","title":"<code>asSparql(filterClause=None, orderClause=None, pk=None, lang='en')</code>","text":"<p>get the sparqlQuery for this query optionally applying a filterClause</p> <p>Parameters:</p> Name Type Description Default <code>filterClause(str)</code> <p>a filter to be applied (if any)</p> required <code>orderClause(str)</code> <p>an orderClause to be applied (if any)</p> required <code>pk(str)</code> <p>primaryKey (if any)</p> required <code>lang(str)</code> <p>the language to be used for labels</p> required Source code in <code>ez_wikidata/wbquery.py</code> <pre><code>    def asSparql(\n        self,\n        filterClause: str = None,\n        orderClause: str = None,\n        pk: str = None,\n        lang: str = \"en\",\n    ) -&gt; str:\n        \"\"\"\n        get the sparqlQuery for this query optionally applying a filterClause\n\n        Args:\n            filterClause(str): a filter to be applied (if any)\n            orderClause(str): an orderClause to be applied (if any)\n            pk(str): primaryKey (if any)\n            lang(str): the language to be used for labels\n        \"\"\"\n        item_mapping = self.get_item_mapping()\n        item_varname = item_mapping.varname\n        sparql = f\"\"\"# \n# get {self.entity} records \n#  \nPREFIX pq: &lt;http://www.wikidata.org/prop/qualifier/&gt;\nPREFIX p: &lt;http://www.wikidata.org/prop/&gt;\nPREFIX schema: &lt;http://schema.org/&gt;\nPREFIX wd: &lt;http://www.wikidata.org/entity/&gt;\nPREFIX wdt: &lt;http://www.wikidata.org/prop/direct/&gt;\nPREFIX wikibase: &lt;http://wikiba.se/ontology#&gt;\nPREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\nSELECT ?{item_varname} ?{item_varname}Label ?{item_varname}Description\n\"\"\"\n        for prop_map in self.get_property_mappings():\n            if prop_map.is_item_itself():\n                continue\n            if not prop_map.value and prop_map.varname:\n                property_selections = f\"\\n  ?{prop_map.varname}\"\n                if prop_map.property_type_enum is WdDatatype.itemid:\n                    # items will automatically fetch labels\n                    property_selections += f\" ?{prop_map.varname}Label\"\n                elif prop_map.property_type_enum is WdDatatype.extid:\n                    # extid' will automatically fetch formatted URIs\n                    property_selections += f\" ?{prop_map.varname}Url\"\n                sparql += property_selections\n        query_item_label = f\"\"\"?{item_varname} rdfs:label ?{item_varname}Label. FILTER(LANG(?{item_varname}Label) = \"{lang}\")\"\"\"\n        query_item_desc = f\"\"\"?{item_varname} schema:description ?{item_varname}Description. FILTER(LANG(?{item_varname}Description) = \"{lang}\")\"\"\"\n        sparql += f\"\"\"\\nWHERE {{\n    {query_item_label}\n    OPTIONAL {{\n        {query_item_desc}\n    }}\n\"\"\"\n        for prop_map in self.get_property_mappings():\n            if prop_map.propertyId in [None, \"\"]:\n                continue\n            if prop_map.value:\n                # value predefined for property\n                sparql += f\"\\n  ?{item_varname} wdt:{prop_map.propertyId} wd:{prop_map.value}.\"\n            else:\n                if prop_map.varname:\n                    # primary keys are not optional\n                    optional = pk is None or not prop_map.propertyName == pk\n                    if optional:\n                        sparql += \"\\n  OPTIONAL {\"\n                    sparql += f\"\\n    ?{item_varname} wdt:{prop_map.propertyId} ?{prop_map.varname}.\"\n                    if prop_map.property_type_enum is WdDatatype.itemid:\n                        # also query label of the qid with language lang\n                        sparql += f\"\\n    ?{prop_map.varname} rdfs:label ?{prop_map.varname}Label.\"\n                        sparql += f\"\"\"\\n    FILTER(LANG(?{prop_map.varname}Label) = \"{lang}\")\"\"\"\n                    elif prop_map.property_type_enum is WdDatatype.extid:\n                        # ToDo: decision to make see https://github.com/WolfgangFahl/PyGenericSpreadSheet/issues/15\n                        sparql += f\"\\n    wd:{prop_map.propertyId} wdt:P1630 ?{prop_map.varname}FormatterUrl.\"\n                        sparql += f\"\\n    BIND(IRI(REPLACE(?{prop_map.varname}, '^(.+)$', ?{prop_map.varname}FormatterUrl)) AS ?{prop_map.varname}Url).\"\n                    if optional:\n                        sparql += \"\\n  }\"\n        if filterClause is not None:\n            sparql += f\"\\n{filterClause}\"\n        sparql += \"\\n}\"\n        if orderClause is not None:\n            sparql += f\"\\n{orderClause}\"\n        return sparql\n</code></pre>"},{"location":"#ez_wikidata.wbquery.WikibaseQuery.getColumnTypeAndVarname","title":"<code>getColumnTypeAndVarname(propName)</code>","text":"<p>get a signature tuple consisting of columnName, propertType and SPARQL variable Name for the given property Name</p> <p>Parameters:</p> Name Type Description Default <code>propName(str)</code> <p>the name of the property</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if property name is not known</p> <p>Returns:</p> Type Description <code>(str, str, str)</code> <p>column,propType,varName tupel</p> Source code in <code>ez_wikidata/wbquery.py</code> <pre><code>def getColumnTypeAndVarname(self, propName: str) -&gt; (str, str, str):\n    \"\"\"\n    get a signature tuple consisting of columnName, propertType and SPARQL variable Name for the given property Name\n\n    Args:\n        propName(str): the name of the property\n\n    Raises:\n        Exception: if property name is not known\n\n    Returns:\n        column,propType,varName tupel\n    \"\"\"\n    if propName in self.propertiesByName:\n        propRow = self.propertiesByName[propName]\n        column = propRow[\"Column\"]\n        propType = propRow[\"Type\"]\n        varName = propRow[\"PropVarname\"]\n        if propType == \"item\" and varName in [None, \"\"]:\n            varName = \"item\"\n    else:\n        raise Exception(\n            f\"unknown property name {propName} for entity {self.entity}\"\n        )\n    return column, propType, varName\n</code></pre>"},{"location":"#ez_wikidata.wbquery.WikibaseQuery.getValuesClause","title":"<code>getValuesClause(values, propVarname='short_name', propType='text', lang=None, ignoreEmpty=True, wbPrefix='http://www.wikidata.org/entity/')</code>","text":"<p>create a SPARQL Values clause</p> <p>Parameters:</p> Name Type Description Default <code>values(list)</code> <p>the list of values to create values for</p> required <code>propVarname(str)</code> <p>the property variable name to assign the values for</p> required <code>propType</code> <code>str</code> <code>'text'</code> <code>lang</code> <code>str</code> <p>language of labels to query</p> <code>None</code> <code>ignoreEmpty(bool)</code> <p>ignore empty values if True</p> required <code>wbPrefix(str)</code> <p>a wikibase/wikidata prefix to be removed for items values</p> required <p>Returns:     str: the SPARQL values clause</p> Source code in <code>ez_wikidata/wbquery.py</code> <pre><code>def getValuesClause(\n    self,\n    values: list,\n    propVarname: str = \"short_name\",\n    propType: str = \"text\",\n    lang: str = None,\n    ignoreEmpty: bool = True,\n    wbPrefix: str = \"http://www.wikidata.org/entity/\",\n):\n    \"\"\"\n    create a SPARQL Values clause\n\n    Args:\n        values(list): the list of values to create values for\n        propVarname(str): the property variable name to assign the values for\n        propType:\n        lang: language of labels to query\n        ignoreEmpty(bool): ignore empty values if True\n        wbPrefix(str): a wikibase/wikidata prefix to be removed for items values\n    Returns:\n        str: the SPARQL values clause\n    \"\"\"\n    valuesClause = f\"\\n  VALUES(?{propVarname}) {{\"\n    if lang is not None and propType == \"text\":\n        lang = f\"@{lang}\"\n    else:\n        lang = \"\"\n    for value in values:\n        if value or not ignoreEmpty:\n            if propType in [\"item\", \"itemid\", \"\", None]:\n                if value and value.startswith(wbPrefix):\n                    value = value.replace(wbPrefix, \"\")\n                valuesClause += f\"\\n   ( wd:{value} )\"\n            else:\n                if isinstance(value, str):\n                    # escape single quotes\n                    value = value.replace(\"'\", \"\\\\'\")\n                    valuesClause += f\"\\n  ( '{value}'{lang} )\"\n                else:\n                    valuesClause += f\"\\n  ( {str(value)} )\"\n    valuesClause += \"\\n  }.\"\n    return valuesClause\n</code></pre>"},{"location":"#ez_wikidata.wbquery.WikibaseQuery.get_item_mapping","title":"<code>get_item_mapping()</code>","text":"<p>Get the mapping that describes the wikidata entity item</p> Source code in <code>ez_wikidata/wbquery.py</code> <pre><code>def get_item_mapping(self) -&gt; PropertyMapping:\n    \"\"\"\n    Get the mapping that describes the wikidata entity item\n    \"\"\"\n    return PropertyMapping.get_item_mapping(self.get_property_mappings())\n</code></pre>"},{"location":"#ez_wikidata.wbquery.WikibaseQuery.get_property_mappings","title":"<code>get_property_mappings()</code>","text":"<p>Get the property mappings as PropertyMapping list</p> <p>Returns:</p> Type Description <code>List[PropertyMapping]</code> <p>List[PropertyMapping]: list of PropertyMappings</p> Source code in <code>ez_wikidata/wbquery.py</code> <pre><code>def get_property_mappings(self) -&gt; List[PropertyMapping]:\n    \"\"\"\n    Get the property mappings as PropertyMapping list\n\n    Returns:\n        List[PropertyMapping]: list of PropertyMappings\n    \"\"\"\n    prop_maps = self.wpm.get_mappings_for_records(self.propertiesByColumn)\n    return prop_maps\n</code></pre>"},{"location":"#ez_wikidata.wbquery.WikibaseQuery.inFilter","title":"<code>inFilter(values, propName='short_name', lang='en')</code>","text":"<p>create a SPARQL IN filter clause</p> <p>Parameters:</p> Name Type Description Default <code>values(list)</code> <p>the list of values to filter for</p> required <code>propName(str)</code> <p>the property name to filter with</p> required <code>lang(str)</code> <p>the language to apply</p> required Source code in <code>ez_wikidata/wbquery.py</code> <pre><code>def inFilter(\n    self, values: list, propName: str = \"short_name\", lang: str = \"en\"\n) -&gt; str:\n    \"\"\"\n    create a SPARQL IN filter clause\n\n    Args:\n        values(list): the list of values to filter for\n        propName(str): the property name to filter with\n        lang(str): the language to apply\n    \"\"\"\n    filterClause = f\"\\n  FILTER(?{propName} IN(\"\n    delim = \"\"\n    for value in values:\n        filterClause += f\"{delim}\\n    '{value}'@{lang}\"\n        delim = \",\"\n    filterClause += \"\\n  )).\"\n    return filterClause\n</code></pre>"},{"location":"#ez_wikidata.wbquery.WikibaseQuery.ofEntityMap","title":"<code>ofEntityMap(entity, entityMap)</code>  <code>classmethod</code>","text":"<p>create a WikibaseQuery for the given entity and entityMap</p> <p>Parameters:</p> Name Type Description Default <code>entity(str)</code> <p>the entity name</p> required <code>entityMap(dict)</code> <p>the entity property descriptions</p> required <p>Returns:     WikibaseQuery</p> Source code in <code>ez_wikidata/wbquery.py</code> <pre><code>@classmethod\ndef ofEntityMap(cls, entity: str, entityMap: dict) -&gt; \"WikibaseQuery\":\n    \"\"\"\n    create a WikibaseQuery for the given entity and entityMap\n\n    Args:\n        entity(str): the entity name\n        entityMap(dict): the entity property descriptions\n    Returns:\n        WikibaseQuery\n    \"\"\"\n    wbQuery = WikibaseQuery(entity)\n    for row in entityMap.values():\n        wbQuery.addPropertyFromDescriptionRow(row)\n    return wbQuery\n</code></pre>"},{"location":"#ez_wikidata.wbquery.WikibaseQuery.ofMapRows","title":"<code>ofMapRows(entityMapRows, debug=False)</code>  <code>classmethod</code>","text":"<p>create a dict of wikibaseQueries from the given entityMap list of dicts</p> <p>Parameters:</p> Name Type Description Default <code>entityMapRows(list)</code> <p>a list of dict with row descriptions</p> required <code>debug(bool)</code> <p>if True switch on debugging</p> required Source code in <code>ez_wikidata/wbquery.py</code> <pre><code>@classmethod\ndef ofMapRows(\n    cls, entityMapRows: list, debug: bool = False\n) -&gt; Dict[str, \"WikibaseQuery\"]:\n    \"\"\"\n    create a dict of wikibaseQueries from the given entityMap list of dicts\n\n    Args:\n        entityMapRows(list): a list of dict with row descriptions\n        debug(bool): if True switch on debugging\n    \"\"\"\n    queries = {}\n    entityMapDict = {}\n    for row in entityMapRows:\n        if \"Entity\" in row:\n            entity = row[\"Entity\"]\n            if not entity in entityMapDict:\n                entityMapDict[entity] = {}\n            entityRows = entityMapDict[entity]\n            if \"PropertyName\" in row:\n                propertyName = row[\"PropertyName\"]\n                entityRows[propertyName] = row\n    if debug:\n        pprint.pprint(entityMapDict)\n    for entity in entityMapDict:\n        wbQuery = WikibaseQuery.ofEntityMap(entity, entityMapDict[entity])\n        queries[entity] = wbQuery\n    return queries\n</code></pre>"},{"location":"#ez_wikidata.wdproperty","title":"<code>wdproperty</code>","text":"<p>Created on 02.03.2024-03-02</p> <p>@author: wf</p>"},{"location":"#ez_wikidata.wdproperty.PropertyMapping","title":"<code>PropertyMapping</code>","text":"<p>Represents a single column Wikidata property mapping.</p> <p>Attributes:</p> Name Type Description <code>column</code> <code>Optional[str]</code> <p>The column name in the data source; if None, the value is directly used.</p> <code>propertyName</code> <code>str</code> <p>The human-readable name of the property.</p> <code>propertyId</code> <code>str</code> <p>The Wikidata property ID (e.g., \"P31\").</p> <code>propertyType</code> <code>str</code> <p>The type of the property as a string; converted to an enum in post-init.</p> <code>qualifierOf</code> <code>Optional[str]</code> <p>Specifies if the property is a qualifier of another property.</p> <code>valueLookupType</code> <code>Optional[Any]</code> <p>The type (instance of/P31) of the property value for lookup if the value is not already a QID.</p> <code>value</code> <code>Optional[Any]</code> <p>The default value to set for the property.</p> <code>varname</code> <code>Optional[str]</code> <p>An optional variable name for internal use.</p> <code>property_type_enum</code> <code>WdDatatype</code> <p>The enum representation of the property type, initialized based on propertyType.</p> <p>The post_init method ensures the propertyType is correctly interpreted and stored as both a string and an enum.</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>@lod_storable\nclass PropertyMapping:\n    \"\"\"\n    Represents a single column Wikidata property mapping.\n\n    Attributes:\n        column (Optional[str]): The column name in the data source; if None, the value is directly used.\n        propertyName (str): The human-readable name of the property.\n        propertyId (str): The Wikidata property ID (e.g., \"P31\").\n        propertyType (str): The type of the property as a string; converted to an enum in post-init.\n        qualifierOf (Optional[str]): Specifies if the property is a qualifier of another property.\n        valueLookupType (Optional[Any]): The type (instance of/P31) of the property value for lookup if the value is not already a QID.\n        value (Optional[Any]): The default value to set for the property.\n        varname (Optional[str]): An optional variable name for internal use.\n        property_type_enum (WdDatatype): The enum representation of the property type, initialized based on propertyType.\n\n    The __post_init__ method ensures the propertyType is correctly interpreted and stored as both a string and an enum.\n    \"\"\"\n\n    column: Union[str, None]  # if None, the value is used\n    propertyName: str\n    propertyId: str\n    propertyType: str\n    qualifierOf: str = None\n    valueLookupType: Any = None  # type (instance of/P31) of the property value \u2192 used to lookup the qid if property value if value is not already a qid\n    value: Any = None  # set this value for the property\n    varname: str = None\n    # property_type_enum: WdDatatype=field(init=False)\n\n    def __post_init__(self):\n        \"\"\"\n        Convert propertyType from string to WdDatatype enum if necessary\n        \"\"\"\n        self.property_type_enum = None\n        if isinstance(self.propertyType, str):\n            try:\n                self.property_type_enum = WdDatatype[self.propertyType]\n            except KeyError:\n                raise ValueError(f\"Invalid property type: {self.propertyType}\")\n        else:\n            self.property_type_enum = self.propertyType\n            # Ensure propertyType is stored as the correct string representation of the enum for YAML compatibility\n            self.propertyType = self.property_type_enum.name\n\n    @classmethod\n    def get_legacy_mapping(cls) -&gt; dict:\n        \"\"\"\n        Returns the Mapping from old prop map keys to the new once\n        \"\"\"\n        return {\n            \"Column\": \"column\",\n            \"PropertyName\": \"propertyName\",\n            \"PropertyId\": \"propertyId\",\n            \"Type\": \"propertyType\",\n            \"Qualifier\": \"qualifierOf\",\n            \"Lookup\": \"valueLookupType\",\n            \"Value\": \"value\",\n            \"PropVarname\": \"varname\",\n        }\n\n    @classmethod\n    def from_record(\n        cls, wpm: WikidataPropertyManager, record: dict\n    ) -&gt; \"PropertyMapping\":\n        \"\"\"\n        initialize PropertyMapping from the given record\n        Args:\n            wpm(WikidataPropertyManager): to be used for type lookup\n            record(Dict): property mapping information\n\n        Returns:\n            PropertyMapping\n        \"\"\"\n        legacy_lookup = cls.get_legacy_mapping()\n        record = record.copy()\n        for i in range(len(record)):\n            key = list(record.keys())[i]\n            if key in legacy_lookup:\n                record[legacy_lookup[key]] = record[key]\n        # handle missing property type\n        property_type = record.get(\"propertyType\", None)\n        if property_type in [None, \"\"]:\n            if record.get(\"valueLookupType\", None) not in [None, \"\"]:\n                property_type = WdDatatype.itemid\n            elif record.get(\"value\", None) not in [None, \"\"]:\n                property_type = WdDatatype.itemid\n        if property_type is not None and not isinstance(property_type, WdDatatype):\n            if property_type in [wd.name for wd in WdDatatype]:\n                property_type = WdDatatype[property_type]\n            else:\n                pid = record.get(\"propertyId\")\n                props = wpm.get_properties_by_ids([pid])\n                if len(props) == 1:\n                    prop = list(props.values())[0]\n                    property_type = prop.ptype\n        mapping = PropertyMapping(\n            column=record.get(\"column\", None),\n            propertyName=record.get(\"propertyName\", None),\n            propertyId=record.get(\"propertyId\", None),\n            propertyType=property_type,\n            qualifierOf=record.get(\"qualifierOf\", None),\n            valueLookupType=record.get(\"valueLookupType\", None),\n            value=record.get(\"value\", None),\n            varname=record.get(\"varname\", None),\n        )\n        return mapping\n\n    def to_record(self) -&gt; dict:\n        \"\"\"\n        convert property mapping to its dict representation\n        \"\"\"\n        key_map = self.get_legacy_mapping()\n        record = dict()\n        for old_key, new_key in key_map.items():\n            record[old_key] = getattr(self, new_key, None)\n        return record\n\n    def is_qualifier(self) -&gt; bool:\n        \"\"\"\n        Returns true if the property mapping describes a qualifier\n        \"\"\"\n        is_qualifier = not (self.qualifierOf is None or self.qualifierOf == \"\")\n        return is_qualifier\n\n    @classmethod\n    def getDefaultItemPropertyMapping(cls) -&gt; \"PropertyMapping\":\n        \"\"\"\n        get the defaultItemPropertyMapping\n        \"\"\"\n        if not hasattr(cls, \"defaultItemPropertyMapping\"):\n            item_prop_map = PropertyMapping(\n                column=\"item\",\n                propertyName=\"item\",\n                propertyId=\"\",\n                propertyType=WdDatatype.item,\n                varname=\"item\",\n            )\n            cls.defaultItemPropertyMapping = item_prop_map\n        return cls.defaultItemPropertyMapping\n\n    def is_item_itself(self) -&gt; bool:\n        \"\"\"\n        Check if the property_type is an item\n\n        Returns:\n            bool: True if the property mapping links to the existing item\n        \"\"\"\n        is_item_id = self.property_type_enum == WdDatatype.item\n        return is_item_id\n\n    @classmethod\n    def get_qualifier_lookup(\n        cls, properties: List[\"PropertyMapping\"]\n    ) -&gt; Dict[str, List[\"PropertyMapping\"]]:\n        \"\"\"\n        Get a lookup for a property and all its qualifier\n\n        Args:\n            properties: property mappings to generate the lookup from\n\n        Returns:\n             dict as property qualifier lookup\n        \"\"\"\n        res = dict()\n        for pm in properties:\n            if not isinstance(pm, PropertyMapping):\n                continue\n            if pm.qualifierOf is None or pm.qualifierOf == \"\":\n                continue\n            else:\n                if pm.qualifierOf in res:\n                    res[pm.qualifierOf].append(pm)\n                else:\n                    res[pm.qualifierOf] = [pm]\n        return res\n\n    @classmethod\n    def get_item_mapping(\n        cls, property_mappings: List[\"PropertyMapping\"]\n    ) -&gt; \"PropertyMapping\":\n        \"\"\"\n        get the property mapping that is used for the default \"item\" primary key\n        if no property is defined use the default \"item\" mapping\n        \"\"\"\n        for pm in property_mappings:\n            if pm.is_item_itself():\n                return pm\n        pm = cls.getDefaultItemPropertyMapping()\n        return pm\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.PropertyMapping.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Convert propertyType from string to WdDatatype enum if necessary</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Convert propertyType from string to WdDatatype enum if necessary\n    \"\"\"\n    self.property_type_enum = None\n    if isinstance(self.propertyType, str):\n        try:\n            self.property_type_enum = WdDatatype[self.propertyType]\n        except KeyError:\n            raise ValueError(f\"Invalid property type: {self.propertyType}\")\n    else:\n        self.property_type_enum = self.propertyType\n        # Ensure propertyType is stored as the correct string representation of the enum for YAML compatibility\n        self.propertyType = self.property_type_enum.name\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.PropertyMapping.from_record","title":"<code>from_record(wpm, record)</code>  <code>classmethod</code>","text":"<p>initialize PropertyMapping from the given record Args:     wpm(WikidataPropertyManager): to be used for type lookup     record(Dict): property mapping information</p> <p>Returns:</p> Type Description <code>PropertyMapping</code> <p>PropertyMapping</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>@classmethod\ndef from_record(\n    cls, wpm: WikidataPropertyManager, record: dict\n) -&gt; \"PropertyMapping\":\n    \"\"\"\n    initialize PropertyMapping from the given record\n    Args:\n        wpm(WikidataPropertyManager): to be used for type lookup\n        record(Dict): property mapping information\n\n    Returns:\n        PropertyMapping\n    \"\"\"\n    legacy_lookup = cls.get_legacy_mapping()\n    record = record.copy()\n    for i in range(len(record)):\n        key = list(record.keys())[i]\n        if key in legacy_lookup:\n            record[legacy_lookup[key]] = record[key]\n    # handle missing property type\n    property_type = record.get(\"propertyType\", None)\n    if property_type in [None, \"\"]:\n        if record.get(\"valueLookupType\", None) not in [None, \"\"]:\n            property_type = WdDatatype.itemid\n        elif record.get(\"value\", None) not in [None, \"\"]:\n            property_type = WdDatatype.itemid\n    if property_type is not None and not isinstance(property_type, WdDatatype):\n        if property_type in [wd.name for wd in WdDatatype]:\n            property_type = WdDatatype[property_type]\n        else:\n            pid = record.get(\"propertyId\")\n            props = wpm.get_properties_by_ids([pid])\n            if len(props) == 1:\n                prop = list(props.values())[0]\n                property_type = prop.ptype\n    mapping = PropertyMapping(\n        column=record.get(\"column\", None),\n        propertyName=record.get(\"propertyName\", None),\n        propertyId=record.get(\"propertyId\", None),\n        propertyType=property_type,\n        qualifierOf=record.get(\"qualifierOf\", None),\n        valueLookupType=record.get(\"valueLookupType\", None),\n        value=record.get(\"value\", None),\n        varname=record.get(\"varname\", None),\n    )\n    return mapping\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.PropertyMapping.getDefaultItemPropertyMapping","title":"<code>getDefaultItemPropertyMapping()</code>  <code>classmethod</code>","text":"<p>get the defaultItemPropertyMapping</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>@classmethod\ndef getDefaultItemPropertyMapping(cls) -&gt; \"PropertyMapping\":\n    \"\"\"\n    get the defaultItemPropertyMapping\n    \"\"\"\n    if not hasattr(cls, \"defaultItemPropertyMapping\"):\n        item_prop_map = PropertyMapping(\n            column=\"item\",\n            propertyName=\"item\",\n            propertyId=\"\",\n            propertyType=WdDatatype.item,\n            varname=\"item\",\n        )\n        cls.defaultItemPropertyMapping = item_prop_map\n    return cls.defaultItemPropertyMapping\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.PropertyMapping.get_item_mapping","title":"<code>get_item_mapping(property_mappings)</code>  <code>classmethod</code>","text":"<p>get the property mapping that is used for the default \"item\" primary key if no property is defined use the default \"item\" mapping</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>@classmethod\ndef get_item_mapping(\n    cls, property_mappings: List[\"PropertyMapping\"]\n) -&gt; \"PropertyMapping\":\n    \"\"\"\n    get the property mapping that is used for the default \"item\" primary key\n    if no property is defined use the default \"item\" mapping\n    \"\"\"\n    for pm in property_mappings:\n        if pm.is_item_itself():\n            return pm\n    pm = cls.getDefaultItemPropertyMapping()\n    return pm\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.PropertyMapping.get_legacy_mapping","title":"<code>get_legacy_mapping()</code>  <code>classmethod</code>","text":"<p>Returns the Mapping from old prop map keys to the new once</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>@classmethod\ndef get_legacy_mapping(cls) -&gt; dict:\n    \"\"\"\n    Returns the Mapping from old prop map keys to the new once\n    \"\"\"\n    return {\n        \"Column\": \"column\",\n        \"PropertyName\": \"propertyName\",\n        \"PropertyId\": \"propertyId\",\n        \"Type\": \"propertyType\",\n        \"Qualifier\": \"qualifierOf\",\n        \"Lookup\": \"valueLookupType\",\n        \"Value\": \"value\",\n        \"PropVarname\": \"varname\",\n    }\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.PropertyMapping.get_qualifier_lookup","title":"<code>get_qualifier_lookup(properties)</code>  <code>classmethod</code>","text":"<p>Get a lookup for a property and all its qualifier</p> <p>Parameters:</p> Name Type Description Default <code>properties</code> <code>List[PropertyMapping]</code> <p>property mappings to generate the lookup from</p> required <p>Returns:</p> Type Description <code>Dict[str, List[PropertyMapping]]</code> <p>dict as property qualifier lookup</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>@classmethod\ndef get_qualifier_lookup(\n    cls, properties: List[\"PropertyMapping\"]\n) -&gt; Dict[str, List[\"PropertyMapping\"]]:\n    \"\"\"\n    Get a lookup for a property and all its qualifier\n\n    Args:\n        properties: property mappings to generate the lookup from\n\n    Returns:\n         dict as property qualifier lookup\n    \"\"\"\n    res = dict()\n    for pm in properties:\n        if not isinstance(pm, PropertyMapping):\n            continue\n        if pm.qualifierOf is None or pm.qualifierOf == \"\":\n            continue\n        else:\n            if pm.qualifierOf in res:\n                res[pm.qualifierOf].append(pm)\n            else:\n                res[pm.qualifierOf] = [pm]\n    return res\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.PropertyMapping.is_item_itself","title":"<code>is_item_itself()</code>","text":"<p>Check if the property_type is an item</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the property mapping links to the existing item</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>def is_item_itself(self) -&gt; bool:\n    \"\"\"\n    Check if the property_type is an item\n\n    Returns:\n        bool: True if the property mapping links to the existing item\n    \"\"\"\n    is_item_id = self.property_type_enum == WdDatatype.item\n    return is_item_id\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.PropertyMapping.is_qualifier","title":"<code>is_qualifier()</code>","text":"<p>Returns true if the property mapping describes a qualifier</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>def is_qualifier(self) -&gt; bool:\n    \"\"\"\n    Returns true if the property mapping describes a qualifier\n    \"\"\"\n    is_qualifier = not (self.qualifierOf is None or self.qualifierOf == \"\")\n    return is_qualifier\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.PropertyMapping.to_record","title":"<code>to_record()</code>","text":"<p>convert property mapping to its dict representation</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>def to_record(self) -&gt; dict:\n    \"\"\"\n    convert property mapping to its dict representation\n    \"\"\"\n    key_map = self.get_legacy_mapping()\n    record = dict()\n    for old_key, new_key in key_map.items():\n        record[old_key] = getattr(self, new_key, None)\n    return record\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.PropertyMappings","title":"<code>PropertyMappings</code>  <code>dataclass</code>","text":"<p>A collection of Wikidata property mappings, with metadata.</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>@lod_storable\n@dataclass\nclass PropertyMappings:\n    \"\"\"\n    A collection of Wikidata property mappings, with metadata.\n    \"\"\"\n\n    name: str\n    mappings: Dict[str, PropertyMapping] = field(default_factory=dict)\n    description: Optional[str] = None\n    url: Optional[str] = None\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.Variable","title":"<code>Variable</code>","text":"<p>Variable e.g. name handling</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>class Variable:\n    \"\"\"\n    Variable e.g. name handling\n    \"\"\"\n\n    @classmethod\n    def validVarName(cls, varStr: str) -&gt; str:\n        \"\"\"\n        convert the given potential variable name string to a valid\n        variable name\n\n        see https://stackoverflow.com/a/3305731/1497139\n\n        Args:\n            varStr(str): the string to convert\n\n        Returns:\n            str: a valid variable name\n        \"\"\"\n        return re.sub(\"\\W|^(?=\\d)\", \"_\", varStr)\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.Variable.validVarName","title":"<code>validVarName(varStr)</code>  <code>classmethod</code>","text":"<p>convert the given potential variable name string to a valid variable name</p> <p>see https://stackoverflow.com/a/3305731/1497139</p> <p>Parameters:</p> Name Type Description Default <code>varStr(str)</code> <p>the string to convert</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>a valid variable name</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>@classmethod\ndef validVarName(cls, varStr: str) -&gt; str:\n    \"\"\"\n    convert the given potential variable name string to a valid\n    variable name\n\n    see https://stackoverflow.com/a/3305731/1497139\n\n    Args:\n        varStr(str): the string to convert\n\n    Returns:\n        str: a valid variable name\n    \"\"\"\n    return re.sub(\"\\W|^(?=\\d)\", \"_\", varStr)\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.WdDatatype","title":"<code>WdDatatype</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Supported Wikidata datatypes, sorted by frequency and including special cases.</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>class WdDatatype(Enum):\n    \"\"\"\n    Supported Wikidata datatypes, sorted by frequency and including special cases.\n    \"\"\"\n\n    extid = auto()  # ExternalId: 8645 occurrences\n    itemid = auto()  # WikibaseItem: 1634 occurrences\n    quantity = auto()  # Quantity: 652 occurrences\n    string = auto()  # String: 329 occurrences\n    url = auto()  # Url: 107 occurrences\n    commons_media = auto()  # CommonsMedia: 79 occurrences\n    time = auto()  # Time: 66 occurrences\n    text = auto()  # Monolingualtext: 62 occurrences\n    math = auto()  # Math: 36 occurrences\n    wikibase_property = auto()  # WikibaseProperty: 21 occurrences\n    wikibase_sense = auto()  # WikibaseSense: 19 occurrences\n    wikibase_lexeme = auto()  # WikibaseLexeme: 17 occurrences\n    globe_coordinate = auto()  # GlobeCoordinate: 11 occurrences\n    wikibase_form = auto()  # WikibaseForm: 9 occurrences\n    musical_notation = auto()  # MusicalNotation: 6 occurrences\n    tabular_data = auto()  # TabularData: 6 occurrences\n    geoshape = auto()  # GeoShape: 3 occurrences\n    # Special cases:\n    item = auto()  # Item: Special case\n    year = auto()  # Year: Special case\n    date = auto()  # Date: Special case\n\n    @classmethod\n    def from_wb_type_name(cls, wb_type_name: str) -&gt; \"WdDatatype\":\n        \"\"\"\n        convert a wikibase type name to a WdDatatype\n\n        Args:\n            wb_type_name(str): the string name of the wikibase type (with or without wikibase ontology prefix)\n        \"\"\"\n        type_map = {\n            \"ExternalId\": cls.extid,\n            \"WikibaseItem\": cls.itemid,\n            \"Quantity\": cls.quantity,\n            \"String\": cls.string,\n            \"Url\": cls.url,\n            \"CommonsMedia\": cls.commons_media,\n            \"Time\": cls.time,\n            \"Monolingualtext\": cls.text,\n            \"Math\": cls.math,\n            \"WikibaseProperty\": cls.wikibase_property,\n            \"WikibaseSense\": cls.wikibase_sense,\n            \"WikibaseLexeme\": cls.wikibase_lexeme,\n            \"GlobeCoordinate\": cls.globe_coordinate,\n            \"WikibaseForm\": cls.wikibase_form,\n            \"MusicalNotation\": cls.musical_notation,\n            \"TabularData\": cls.tabular_data,\n            \"GeoShape\": cls.geoshape,\n        }\n        wb_type_name = wb_type_name.replace(\"http://wikiba.se/ontology#\", \"\")\n        wd_type = type_map.get(wb_type_name, WdDatatype.string)\n        return wd_type\n\n    @classmethod\n    def _missing_(cls, _value):\n        \"\"\"\n        default datatype\n        \"\"\"\n        return cls.text\n\n    @classmethod\n    def get_by_wikibase(cls, property_type: str) -&gt; Union[\"WdDatatype\", None]:\n        \"\"\"\n        Get WdDatatype by the corresponding wikibase datatype\n        Args:\n            property_type: wikibase name of the type\n\n        Returns:\n            WdDatatype\n        \"\"\"\n        wikibase_map = {\n            \"WikibaseItem\": cls.itemid,\n            \"Time\": cls.date,\n            \"Monolingualtext\": cls.text,\n            \"String\": cls.string,\n            \"ExternalId\": cls.extid,\n            \"Url\": cls.url,\n        }\n        return wikibase_map.get(property_type, None)\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.WdDatatype.from_wb_type_name","title":"<code>from_wb_type_name(wb_type_name)</code>  <code>classmethod</code>","text":"<p>convert a wikibase type name to a WdDatatype</p> <p>Parameters:</p> Name Type Description Default <code>wb_type_name(str)</code> <p>the string name of the wikibase type (with or without wikibase ontology prefix)</p> required Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>@classmethod\ndef from_wb_type_name(cls, wb_type_name: str) -&gt; \"WdDatatype\":\n    \"\"\"\n    convert a wikibase type name to a WdDatatype\n\n    Args:\n        wb_type_name(str): the string name of the wikibase type (with or without wikibase ontology prefix)\n    \"\"\"\n    type_map = {\n        \"ExternalId\": cls.extid,\n        \"WikibaseItem\": cls.itemid,\n        \"Quantity\": cls.quantity,\n        \"String\": cls.string,\n        \"Url\": cls.url,\n        \"CommonsMedia\": cls.commons_media,\n        \"Time\": cls.time,\n        \"Monolingualtext\": cls.text,\n        \"Math\": cls.math,\n        \"WikibaseProperty\": cls.wikibase_property,\n        \"WikibaseSense\": cls.wikibase_sense,\n        \"WikibaseLexeme\": cls.wikibase_lexeme,\n        \"GlobeCoordinate\": cls.globe_coordinate,\n        \"WikibaseForm\": cls.wikibase_form,\n        \"MusicalNotation\": cls.musical_notation,\n        \"TabularData\": cls.tabular_data,\n        \"GeoShape\": cls.geoshape,\n    }\n    wb_type_name = wb_type_name.replace(\"http://wikiba.se/ontology#\", \"\")\n    wd_type = type_map.get(wb_type_name, WdDatatype.string)\n    return wd_type\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.WdDatatype.get_by_wikibase","title":"<code>get_by_wikibase(property_type)</code>  <code>classmethod</code>","text":"<p>Get WdDatatype by the corresponding wikibase datatype Args:     property_type: wikibase name of the type</p> <p>Returns:</p> Type Description <code>Union[WdDatatype, None]</code> <p>WdDatatype</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>@classmethod\ndef get_by_wikibase(cls, property_type: str) -&gt; Union[\"WdDatatype\", None]:\n    \"\"\"\n    Get WdDatatype by the corresponding wikibase datatype\n    Args:\n        property_type: wikibase name of the type\n\n    Returns:\n        WdDatatype\n    \"\"\"\n    wikibase_map = {\n        \"WikibaseItem\": cls.itemid,\n        \"Time\": cls.date,\n        \"Monolingualtext\": cls.text,\n        \"String\": cls.string,\n        \"ExternalId\": cls.extid,\n        \"Url\": cls.url,\n    }\n    return wikibase_map.get(property_type, None)\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.WikidataProperty","title":"<code>WikidataProperty</code>","text":"<p>Represents a Wikidata Property.</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>@lod_storable\nclass WikidataProperty:\n    \"\"\"\n    Represents a Wikidata Property.\n    \"\"\"\n    id: str # the id of the property - pid + lang\n    pid: str  # The property ID\n    lang: str\n    plabel: str  # the label of the property\n    description: str  # Description of the property\n    type_name: str  # the type name\n    reverse: bool = False  # Indicates if the property is used in reverse direction\n    # Variables initialized in __post_init__\n    # varname: str = field(init=False)\n    # valueVarname: str = field(init=False)\n    # labelVarname: str = field(init=False)\n    # ptype: WdDatatype = field(init=False)\n\n    def __post_init__(self):\n        \"\"\"\n        creates and modify calculated fields\n        \"\"\"\n        # not needed any more but does not hurt\n        self.pid = self.pid.replace(\"http://www.wikidata.org/entity/\", \"\")\n        self.url = f\"https://www.wikidata.org/wiki/Property:{self.pid}\"\n        self.ptype = WdDatatype.from_wb_type_name(self.type_name)\n        self.varname = Variable.validVarName(self.plabel)\n        self.valueVarname = (\n            f\"{self.varname}Item\" if \"WikibaseItem\" in self.type_name else self.varname\n        )\n        self.labelVarname = self.varname\n\n    def getPredicate(self):\n        \"\"\"\n        get me as a Predicate\n        \"\"\"\n        reverseToken = \"^\" if self.reverse else \"\"\n        plabel = f\"{reverseToken}wdt:{self.pid}\"\n        return plabel\n\n    def __str__(self):\n        text = self.pid\n        if hasattr(self, \"plabel\"):\n            text = f\"{self.plabel} ({self.pid})\"\n        return text\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.WikidataProperty.__post_init__","title":"<code>__post_init__()</code>","text":"<p>creates and modify calculated fields</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    creates and modify calculated fields\n    \"\"\"\n    # not needed any more but does not hurt\n    self.pid = self.pid.replace(\"http://www.wikidata.org/entity/\", \"\")\n    self.url = f\"https://www.wikidata.org/wiki/Property:{self.pid}\"\n    self.ptype = WdDatatype.from_wb_type_name(self.type_name)\n    self.varname = Variable.validVarName(self.plabel)\n    self.valueVarname = (\n        f\"{self.varname}Item\" if \"WikibaseItem\" in self.type_name else self.varname\n    )\n    self.labelVarname = self.varname\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.WikidataProperty.getPredicate","title":"<code>getPredicate()</code>","text":"<p>get me as a Predicate</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>def getPredicate(self):\n    \"\"\"\n    get me as a Predicate\n    \"\"\"\n    reverseToken = \"^\" if self.reverse else \"\"\n    plabel = f\"{reverseToken}wdt:{self.pid}\"\n    return plabel\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.WikidataPropertyManager","title":"<code>WikidataPropertyManager</code>","text":"<p>handle Wikidata Properties</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>class WikidataPropertyManager:\n    \"\"\"\n    handle Wikidata Properties\n    \"\"\"\n\n    def __init__(\n        self,\n        endpoint_url: str = \"https://qlever.cs.uni-freiburg.de/api/wikidata\",\n        langs: List[str] = [\"en\", \"zh\", \"hi\", \"de\", \"fr\", \"ar\", \"es\", \"bn\", \"ru\"],\n        with_load: bool = True,\n        profile: bool = True,\n        debug: bool = False,\n    ):\n        \"\"\"\n        initialize the lookups\n        \"\"\"\n        if not \"en\" in langs:\n            raise ValueError(f\"en is mandatory in langs -{langs}\")\n        self.langs = langs\n        self.debug = debug\n        self.profile = profile\n        self.sparql = SPARQL(endpoint_url, debug=self.debug)\n        self.sql_db_path = WikidataPropertyManager.get_cache_path()\n        self.sql_db = SQLDB(self.sql_db_path)\n        self.sparql_query = self.get_query_for_langs(langs)\n        self.props = []\n        self.props_by_id = {}\n        self.props_by_lang = {}\n        self.loaded=False\n        if with_load:\n            self.load()\n\n    def load_from_sparql(self):\n        \"\"\"\n        get my list of dicts from sparql\n        \"\"\"\n        profiler = Profiler(f\"getting wikidata properties for {len(self.langs)} languages via SPARQL\", profile=self.profile)\n        self.lod = self.sparql.queryAsListOfDicts(self.sparql_query)\n        profiler.time()\n\n    def store(self):\n        \"\"\"\n        store my list of dicts\n        \"\"\"\n        profiler = Profiler(f\"caching wikidata properties to SQL\", profile=self.profile)\n        self.entity_info = self.sql_db.createTable(\n            listOfRecords=self.lod,\n            entityName=\"wd_properties\",\n            primaryKey=\"id\",\n            withCreate=True,\n            withDrop=True,\n            sampleRecordCount=100,\n        )\n        self.sql_db.store(\n            listOfRecords=self.lod,\n            entityInfo=self.entity_info,\n            executeMany=True,\n            fixNone=True,\n        )\n        profiler.time()\n\n    def load_from_sql(self):\n        \"\"\"\n        load from SQL\n        \"\"\"\n        profiler = Profiler(\n            f\"loading wikidata properties from SQL\", profile=self.profile\n        )\n        sql_query = \"SELECT * FROM wd_properties\"\n        self.lod = self.sql_db.query(sql_query)\n        profiler.time()\n\n    def load(self):\n        \"\"\"\n        load the properties\n        \"\"\"\n        if self.loaded:\n            return\n        if os.path.isfile(self.sql_db_path) and os.stat(self.sql_db_path).st_size &gt; 0:\n            self.load_from_sql()\n        else:\n            self.load_from_sparql()\n            for record in self.lod:\n                pid=record[\"pid\"]\n                lang=record[\"lang\"]\n                pid = pid.replace(\"http://www.wikidata.org/entity/\", \"\")\n                record[\"pid\"]=pid\n                record[\"id\"]=f\"{pid}-{lang}\"\n            self.store()\n        self.init_props()\n        self.loaded=True\n\n    def init_props(self):\n        \"\"\"\n        initialize my property structures\n        \"\"\"\n        self.props = []\n        self.props_by_id = {}\n        self.props_by_lang = {}\n        if not self.lod:\n            raise Exception(f\"Could not fetch wikidata properties for {self.langs}\")\n        for record in self.lod:\n            prop = WikidataProperty(**record)\n            self.props.append(prop)\n        for lang in self.langs:\n            self.props_by_lang[lang] = {}\n            self.props_by_id[lang]={}\n        for prop in self.props:\n            self.props_by_lang[prop.lang][prop.plabel] = prop\n            self.props_by_id[prop.lang][prop.pid] = prop\n\n    def get_mappings_for_records(\n        self, prop_mapping_records: Dict[str, dict]\n    ) -&gt; List[\"PropertyMapping\"]:\n        \"\"\"\n        convert given list of property mapping records to list of PropertyMappings\n        Args:\n            prop_mapping_records: records to convert\n\n        Returns:\n            property mappings\n        \"\"\"\n        mappings = []\n        for record in prop_mapping_records.values():\n            mapping = PropertyMapping.from_record(self, record)\n            mappings.append(mapping)\n        return mappings\n\n    def get_query_for_langs(self, langs: list = None) -&gt; str:\n        \"\"\"\n        Get the SPARQL query for the given list of langs.\n        \"\"\"\n        query_prefix = Prefixes.getPrefixes([\"wikibase\", \"rdfs\", \"schema\"])\n        query_body = \"\"\n        if langs is None:\n            langs = self.langs\n        for lang in langs:\n            if query_body:  # If not the first iteration, add UNION\n                query_body += \"\\n  UNION\"\n            query_body += f\"\"\"\n  {{ # wikidata properties with {lang} labels and descriptions\n    ?property a wikibase:Property;\n    rdfs:label ?propertyLabel;\n    schema:description ?propertyDescription;\n    wikibase:propertyType ?wbType.\n    FILTER(LANG(?propertyLabel) = \"{lang}\") .\n    FILTER(LANG(?propertyDescription) = \"{lang}\") .\n    BIND(\"{lang}\" AS ?lang)\n  }}\"\"\"\n        query = (\n            query_prefix + \"SELECT \\n\"\n            \"  (STR(?property) AS ?pid)\\n\"\n            \"  ?lang\\n\"\n            \"  (?propertyLabel AS ?plabel)\\n\"\n            \"  (?propertyDescription AS ?description)\\n\"\n            \"  (STR(?wbType) AS ?type_name)\\n\"\n            \"WHERE {\" + query_body + \"\\n}\\n\"\n        )\n        return query\n\n    @classmethod\n    def get_instance(\n        cls,\n        endpoint_url: str = \"https://qlever.cs.uni-freiburg.de/api/wikidata\",\n    ) -&gt; \"WikidataPropertyManager\":\n        \"\"\"\n        initialize the wikidata property manager\n\n        Args:\n            endpoint_url(str): the SPARQL endpoint to query if there is no cache available\n            lang(str): the languages to query propery labels and descriptions for\n        \"\"\"\n        if not hasattr(cls, \"wpm\"):\n            cls.wpm = WikidataPropertyManager(endpoint_url)\n        return cls.wpm\n\n    @classmethod\n    def get_cache_path(cls, lang: str = \"en\") -&gt; str:\n        home = str(Path.home())\n        cache_dir = f\"{home}/.wikidata\"\n        os.makedirs(cache_dir, exist_ok=True)\n        cache_path = f\"{cache_dir}/wikidata_properties.db\"\n        return cache_path\n\n    def get_properties_by_labels(\n        self, labels: List[str], lang: str = \"en\"\n    ) -&gt; Dict[str, WikidataProperty]:\n        \"\"\"\n        Get properties by their labels for a specific language.\n\n        Args:\n            labels: List of property labels to search for.\n            lang: the language to match with\n        Returns:\n            A dictionary of {label: WikidataProperty} for found properties.\n        \"\"\"\n        matched_properties = {}\n        # Check if language exists in cached properties\n        # Iterate over requested labels and try to find them in the cached properties\n        for label in labels:\n            if label in self.props_by_lang[lang]:\n                matched_properties[label] = self.props_by_lang[lang][label]\n        return matched_properties\n\n    def get_properties_by_ids(\n        self, ids: List[str],lang:str=\"en\"\n    ) -&gt; Dict[str, Optional[WikidataProperty]]:\n        \"\"\"\n        Get properties by their IDs for a specific language.\n\n        Args:\n            ids: List of property IDs to search for.\n            lang(str): the language\n\n        Returns:\n            A dictionary of {property ID: WikidataProperty or None} for found and not found properties.\n        \"\"\"\n        matched_properties = {}\n        for pid in ids:\n            # first check requested language\n            if pid in self.props_by_id[lang]:\n                matched_properties[pid] = self.props_by_id[lang][pid]\n            elif pid in self.props_by_lang[\"en\"]:\n                # fall back to english\n                matched_properties[pid] = self.props_by_id[\"en\"][pid]\n        return matched_properties\n\n    def get_property_by_id(self, property_id: str) -&gt; WikidataProperty:\n        \"\"\"\n        lookup a WikidataProperty for the given property_id\n\n        Args:\n            property_id(str): a property ID e.g. \"P6375\"\n        \"\"\"\n        properties = self.get_properties_by_ids([property_id])\n        prop_count = len(properties)\n        if prop_count == 1:\n            return list(properties.values())[0]\n        elif prop_count == 0:\n            return None\n        else:\n            property_labels = list(properties.keys())\n            msg = f\"unexpected get_property_by_id result for property id {property_id}. Expected 0 or 1 results bot got:{property_labels}\"\n            raise ValueError(msg)\n        pass\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.WikidataPropertyManager.__init__","title":"<code>__init__(endpoint_url='https://qlever.cs.uni-freiburg.de/api/wikidata', langs=['en', 'zh', 'hi', 'de', 'fr', 'ar', 'es', 'bn', 'ru'], with_load=True, profile=True, debug=False)</code>","text":"<p>initialize the lookups</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>def __init__(\n    self,\n    endpoint_url: str = \"https://qlever.cs.uni-freiburg.de/api/wikidata\",\n    langs: List[str] = [\"en\", \"zh\", \"hi\", \"de\", \"fr\", \"ar\", \"es\", \"bn\", \"ru\"],\n    with_load: bool = True,\n    profile: bool = True,\n    debug: bool = False,\n):\n    \"\"\"\n    initialize the lookups\n    \"\"\"\n    if not \"en\" in langs:\n        raise ValueError(f\"en is mandatory in langs -{langs}\")\n    self.langs = langs\n    self.debug = debug\n    self.profile = profile\n    self.sparql = SPARQL(endpoint_url, debug=self.debug)\n    self.sql_db_path = WikidataPropertyManager.get_cache_path()\n    self.sql_db = SQLDB(self.sql_db_path)\n    self.sparql_query = self.get_query_for_langs(langs)\n    self.props = []\n    self.props_by_id = {}\n    self.props_by_lang = {}\n    self.loaded=False\n    if with_load:\n        self.load()\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.WikidataPropertyManager.get_instance","title":"<code>get_instance(endpoint_url='https://qlever.cs.uni-freiburg.de/api/wikidata')</code>  <code>classmethod</code>","text":"<p>initialize the wikidata property manager</p> <p>Parameters:</p> Name Type Description Default <code>endpoint_url(str)</code> <p>the SPARQL endpoint to query if there is no cache available</p> required <code>lang(str)</code> <p>the languages to query propery labels and descriptions for</p> required Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>@classmethod\ndef get_instance(\n    cls,\n    endpoint_url: str = \"https://qlever.cs.uni-freiburg.de/api/wikidata\",\n) -&gt; \"WikidataPropertyManager\":\n    \"\"\"\n    initialize the wikidata property manager\n\n    Args:\n        endpoint_url(str): the SPARQL endpoint to query if there is no cache available\n        lang(str): the languages to query propery labels and descriptions for\n    \"\"\"\n    if not hasattr(cls, \"wpm\"):\n        cls.wpm = WikidataPropertyManager(endpoint_url)\n    return cls.wpm\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.WikidataPropertyManager.get_mappings_for_records","title":"<code>get_mappings_for_records(prop_mapping_records)</code>","text":"<p>convert given list of property mapping records to list of PropertyMappings Args:     prop_mapping_records: records to convert</p> <p>Returns:</p> Type Description <code>List[PropertyMapping]</code> <p>property mappings</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>def get_mappings_for_records(\n    self, prop_mapping_records: Dict[str, dict]\n) -&gt; List[\"PropertyMapping\"]:\n    \"\"\"\n    convert given list of property mapping records to list of PropertyMappings\n    Args:\n        prop_mapping_records: records to convert\n\n    Returns:\n        property mappings\n    \"\"\"\n    mappings = []\n    for record in prop_mapping_records.values():\n        mapping = PropertyMapping.from_record(self, record)\n        mappings.append(mapping)\n    return mappings\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.WikidataPropertyManager.get_properties_by_ids","title":"<code>get_properties_by_ids(ids, lang='en')</code>","text":"<p>Get properties by their IDs for a specific language.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>List[str]</code> <p>List of property IDs to search for.</p> required <code>lang(str)</code> <p>the language</p> required <p>Returns:</p> Type Description <code>Dict[str, Optional[WikidataProperty]]</code> <p>A dictionary of {property ID: WikidataProperty or None} for found and not found properties.</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>def get_properties_by_ids(\n    self, ids: List[str],lang:str=\"en\"\n) -&gt; Dict[str, Optional[WikidataProperty]]:\n    \"\"\"\n    Get properties by their IDs for a specific language.\n\n    Args:\n        ids: List of property IDs to search for.\n        lang(str): the language\n\n    Returns:\n        A dictionary of {property ID: WikidataProperty or None} for found and not found properties.\n    \"\"\"\n    matched_properties = {}\n    for pid in ids:\n        # first check requested language\n        if pid in self.props_by_id[lang]:\n            matched_properties[pid] = self.props_by_id[lang][pid]\n        elif pid in self.props_by_lang[\"en\"]:\n            # fall back to english\n            matched_properties[pid] = self.props_by_id[\"en\"][pid]\n    return matched_properties\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.WikidataPropertyManager.get_properties_by_labels","title":"<code>get_properties_by_labels(labels, lang='en')</code>","text":"<p>Get properties by their labels for a specific language.</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>List[str]</code> <p>List of property labels to search for.</p> required <code>lang</code> <code>str</code> <p>the language to match with</p> <code>'en'</code> <p>Returns:     A dictionary of {label: WikidataProperty} for found properties.</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>def get_properties_by_labels(\n    self, labels: List[str], lang: str = \"en\"\n) -&gt; Dict[str, WikidataProperty]:\n    \"\"\"\n    Get properties by their labels for a specific language.\n\n    Args:\n        labels: List of property labels to search for.\n        lang: the language to match with\n    Returns:\n        A dictionary of {label: WikidataProperty} for found properties.\n    \"\"\"\n    matched_properties = {}\n    # Check if language exists in cached properties\n    # Iterate over requested labels and try to find them in the cached properties\n    for label in labels:\n        if label in self.props_by_lang[lang]:\n            matched_properties[label] = self.props_by_lang[lang][label]\n    return matched_properties\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.WikidataPropertyManager.get_property_by_id","title":"<code>get_property_by_id(property_id)</code>","text":"<p>lookup a WikidataProperty for the given property_id</p> <p>Parameters:</p> Name Type Description Default <code>property_id(str)</code> <p>a property ID e.g. \"P6375\"</p> required Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>def get_property_by_id(self, property_id: str) -&gt; WikidataProperty:\n    \"\"\"\n    lookup a WikidataProperty for the given property_id\n\n    Args:\n        property_id(str): a property ID e.g. \"P6375\"\n    \"\"\"\n    properties = self.get_properties_by_ids([property_id])\n    prop_count = len(properties)\n    if prop_count == 1:\n        return list(properties.values())[0]\n    elif prop_count == 0:\n        return None\n    else:\n        property_labels = list(properties.keys())\n        msg = f\"unexpected get_property_by_id result for property id {property_id}. Expected 0 or 1 results bot got:{property_labels}\"\n        raise ValueError(msg)\n    pass\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.WikidataPropertyManager.get_query_for_langs","title":"<code>get_query_for_langs(langs=None)</code>","text":"<p>Get the SPARQL query for the given list of langs.</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>  def get_query_for_langs(self, langs: list = None) -&gt; str:\n      \"\"\"\n      Get the SPARQL query for the given list of langs.\n      \"\"\"\n      query_prefix = Prefixes.getPrefixes([\"wikibase\", \"rdfs\", \"schema\"])\n      query_body = \"\"\n      if langs is None:\n          langs = self.langs\n      for lang in langs:\n          if query_body:  # If not the first iteration, add UNION\n              query_body += \"\\n  UNION\"\n          query_body += f\"\"\"\n{{ # wikidata properties with {lang} labels and descriptions\n  ?property a wikibase:Property;\n  rdfs:label ?propertyLabel;\n  schema:description ?propertyDescription;\n  wikibase:propertyType ?wbType.\n  FILTER(LANG(?propertyLabel) = \"{lang}\") .\n  FILTER(LANG(?propertyDescription) = \"{lang}\") .\n  BIND(\"{lang}\" AS ?lang)\n}}\"\"\"\n      query = (\n          query_prefix + \"SELECT \\n\"\n          \"  (STR(?property) AS ?pid)\\n\"\n          \"  ?lang\\n\"\n          \"  (?propertyLabel AS ?plabel)\\n\"\n          \"  (?propertyDescription AS ?description)\\n\"\n          \"  (STR(?wbType) AS ?type_name)\\n\"\n          \"WHERE {\" + query_body + \"\\n}\\n\"\n      )\n      return query\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.WikidataPropertyManager.init_props","title":"<code>init_props()</code>","text":"<p>initialize my property structures</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>def init_props(self):\n    \"\"\"\n    initialize my property structures\n    \"\"\"\n    self.props = []\n    self.props_by_id = {}\n    self.props_by_lang = {}\n    if not self.lod:\n        raise Exception(f\"Could not fetch wikidata properties for {self.langs}\")\n    for record in self.lod:\n        prop = WikidataProperty(**record)\n        self.props.append(prop)\n    for lang in self.langs:\n        self.props_by_lang[lang] = {}\n        self.props_by_id[lang]={}\n    for prop in self.props:\n        self.props_by_lang[prop.lang][prop.plabel] = prop\n        self.props_by_id[prop.lang][prop.pid] = prop\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.WikidataPropertyManager.load","title":"<code>load()</code>","text":"<p>load the properties</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>def load(self):\n    \"\"\"\n    load the properties\n    \"\"\"\n    if self.loaded:\n        return\n    if os.path.isfile(self.sql_db_path) and os.stat(self.sql_db_path).st_size &gt; 0:\n        self.load_from_sql()\n    else:\n        self.load_from_sparql()\n        for record in self.lod:\n            pid=record[\"pid\"]\n            lang=record[\"lang\"]\n            pid = pid.replace(\"http://www.wikidata.org/entity/\", \"\")\n            record[\"pid\"]=pid\n            record[\"id\"]=f\"{pid}-{lang}\"\n        self.store()\n    self.init_props()\n    self.loaded=True\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.WikidataPropertyManager.load_from_sparql","title":"<code>load_from_sparql()</code>","text":"<p>get my list of dicts from sparql</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>def load_from_sparql(self):\n    \"\"\"\n    get my list of dicts from sparql\n    \"\"\"\n    profiler = Profiler(f\"getting wikidata properties for {len(self.langs)} languages via SPARQL\", profile=self.profile)\n    self.lod = self.sparql.queryAsListOfDicts(self.sparql_query)\n    profiler.time()\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.WikidataPropertyManager.load_from_sql","title":"<code>load_from_sql()</code>","text":"<p>load from SQL</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>def load_from_sql(self):\n    \"\"\"\n    load from SQL\n    \"\"\"\n    profiler = Profiler(\n        f\"loading wikidata properties from SQL\", profile=self.profile\n    )\n    sql_query = \"SELECT * FROM wd_properties\"\n    self.lod = self.sql_db.query(sql_query)\n    profiler.time()\n</code></pre>"},{"location":"#ez_wikidata.wdproperty.WikidataPropertyManager.store","title":"<code>store()</code>","text":"<p>store my list of dicts</p> Source code in <code>ez_wikidata/wdproperty.py</code> <pre><code>def store(self):\n    \"\"\"\n    store my list of dicts\n    \"\"\"\n    profiler = Profiler(f\"caching wikidata properties to SQL\", profile=self.profile)\n    self.entity_info = self.sql_db.createTable(\n        listOfRecords=self.lod,\n        entityName=\"wd_properties\",\n        primaryKey=\"id\",\n        withCreate=True,\n        withDrop=True,\n        sampleRecordCount=100,\n    )\n    self.sql_db.store(\n        listOfRecords=self.lod,\n        entityInfo=self.entity_info,\n        executeMany=True,\n        fixNone=True,\n    )\n    profiler.time()\n</code></pre>"},{"location":"#ez_wikidata.wdsearch","title":"<code>wdsearch</code>","text":"<p>Created on 2022-07-24</p> <p>@author: wf</p>"},{"location":"#ez_wikidata.wdsearch.WikidataSearch","title":"<code>WikidataSearch</code>","text":"<p>               Bases: <code>object</code></p> <p>Wikidata Search API wrapper</p> Source code in <code>ez_wikidata/wdsearch.py</code> <pre><code>class WikidataSearch(object):\n    \"\"\"\n    Wikidata Search API wrapper\n    \"\"\"\n\n    def __init__(self, language: str = \"en\", timeout: float = 2.0):\n        \"\"\"\n        Constructor\n\n        Args:\n            language(str): the language to use e.g. en/fr\n            timeout(float): maximum time to wait for result\n        \"\"\"\n        self.language = language\n        self.timeout = timeout\n\n    def searchOptions(\n        self, searchFor: str, limit: int = 9\n    ) -&gt; List[Tuple[str, str, str]]:\n        \"\"\"\n        Search and return a list of qid, itemLabel, description tuples.\n\n        Args:\n            searchFor (str): the string to search for.\n            limit (int): the maximum amount of results to return.\n\n        Returns:\n            List[Tuple[str, str, str]]:\n            A list of tuples containing\n            qid, itemLabel, and description.\n        \"\"\"\n        options = []\n        srlist = self.search(searchFor, limit)\n        if srlist is not None:\n            for sr in srlist:\n                qid = sr[\"id\"]\n                itemLabel = sr[\"label\"]\n                desc = \"\"\n                if \"display\" in sr:\n                    display = sr[\"display\"]\n                    if \"description\" in display:\n                        desc = display[\"description\"][\"value\"]\n                options.append(\n                    (\n                        qid,\n                        itemLabel,\n                        desc,\n                    )\n                )\n        return options\n\n    def search(self, searchFor: str, limit: int = 9):\n        \"\"\"\n\n        Args:\n            searchFor(str): the string to search for\n            limit(int): the maximum amount of results to search for\n        \"\"\"\n        try:\n            apiurl = f\"https://www.wikidata.org/w/api.php?action=wbsearchentities&amp;language={self.language}&amp;uselang={self.language}&amp;format=json&amp;limit={limit}&amp;search=\"\n            searchEncoded = urllib.parse.quote_plus(searchFor)\n            apisearch = apiurl + searchEncoded\n            with urllib.request.urlopen(apisearch, timeout=self.timeout) as url:\n                searchResult = json.loads(url.read().decode())\n            return searchResult[\"search\"]\n        except Exception as _error:\n            return None\n\n    def getProperties(self):\n        \"\"\"\n        get the Wikidata Properties\n        \"\"\"\n        scriptdir = os.path.dirname(__file__)\n        jsonPath = f\"{scriptdir}/resources/wdprops.json\"\n        with open(jsonPath) as jsonFile:\n            props = json.load(jsonFile)\n        return props\n</code></pre>"},{"location":"#ez_wikidata.wdsearch.WikidataSearch.__init__","title":"<code>__init__(language='en', timeout=2.0)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>language(str)</code> <p>the language to use e.g. en/fr</p> required <code>timeout(float)</code> <p>maximum time to wait for result</p> required Source code in <code>ez_wikidata/wdsearch.py</code> <pre><code>def __init__(self, language: str = \"en\", timeout: float = 2.0):\n    \"\"\"\n    Constructor\n\n    Args:\n        language(str): the language to use e.g. en/fr\n        timeout(float): maximum time to wait for result\n    \"\"\"\n    self.language = language\n    self.timeout = timeout\n</code></pre>"},{"location":"#ez_wikidata.wdsearch.WikidataSearch.getProperties","title":"<code>getProperties()</code>","text":"<p>get the Wikidata Properties</p> Source code in <code>ez_wikidata/wdsearch.py</code> <pre><code>def getProperties(self):\n    \"\"\"\n    get the Wikidata Properties\n    \"\"\"\n    scriptdir = os.path.dirname(__file__)\n    jsonPath = f\"{scriptdir}/resources/wdprops.json\"\n    with open(jsonPath) as jsonFile:\n        props = json.load(jsonFile)\n    return props\n</code></pre>"},{"location":"#ez_wikidata.wdsearch.WikidataSearch.search","title":"<code>search(searchFor, limit=9)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>searchFor(str)</code> <p>the string to search for</p> required <code>limit(int)</code> <p>the maximum amount of results to search for</p> required Source code in <code>ez_wikidata/wdsearch.py</code> <pre><code>def search(self, searchFor: str, limit: int = 9):\n    \"\"\"\n\n    Args:\n        searchFor(str): the string to search for\n        limit(int): the maximum amount of results to search for\n    \"\"\"\n    try:\n        apiurl = f\"https://www.wikidata.org/w/api.php?action=wbsearchentities&amp;language={self.language}&amp;uselang={self.language}&amp;format=json&amp;limit={limit}&amp;search=\"\n        searchEncoded = urllib.parse.quote_plus(searchFor)\n        apisearch = apiurl + searchEncoded\n        with urllib.request.urlopen(apisearch, timeout=self.timeout) as url:\n            searchResult = json.loads(url.read().decode())\n        return searchResult[\"search\"]\n    except Exception as _error:\n        return None\n</code></pre>"},{"location":"#ez_wikidata.wdsearch.WikidataSearch.searchOptions","title":"<code>searchOptions(searchFor, limit=9)</code>","text":"<p>Search and return a list of qid, itemLabel, description tuples.</p> <p>Parameters:</p> Name Type Description Default <code>searchFor</code> <code>str</code> <p>the string to search for.</p> required <code>limit</code> <code>int</code> <p>the maximum amount of results to return.</p> <code>9</code> <p>Returns:</p> Type Description <code>List[Tuple[str, str, str]]</code> <p>List[Tuple[str, str, str]]:</p> <code>List[Tuple[str, str, str]]</code> <p>A list of tuples containing</p> <code>List[Tuple[str, str, str]]</code> <p>qid, itemLabel, and description.</p> Source code in <code>ez_wikidata/wdsearch.py</code> <pre><code>def searchOptions(\n    self, searchFor: str, limit: int = 9\n) -&gt; List[Tuple[str, str, str]]:\n    \"\"\"\n    Search and return a list of qid, itemLabel, description tuples.\n\n    Args:\n        searchFor (str): the string to search for.\n        limit (int): the maximum amount of results to return.\n\n    Returns:\n        List[Tuple[str, str, str]]:\n        A list of tuples containing\n        qid, itemLabel, and description.\n    \"\"\"\n    options = []\n    srlist = self.search(searchFor, limit)\n    if srlist is not None:\n        for sr in srlist:\n            qid = sr[\"id\"]\n            itemLabel = sr[\"label\"]\n            desc = \"\"\n            if \"display\" in sr:\n                display = sr[\"display\"]\n                if \"description\" in display:\n                    desc = display[\"description\"][\"value\"]\n            options.append(\n                (\n                    qid,\n                    itemLabel,\n                    desc,\n                )\n            )\n    return options\n</code></pre>"},{"location":"#ez_wikidata.wikidata","title":"<code>wikidata</code>","text":"<p>Created on 2022-04-18</p> <p>@author: wf</p>"},{"location":"#ez_wikidata.wikidata.UrlReference","title":"<code>UrlReference</code>","text":"<p>               Bases: <code>Reference</code></p> <p>Reference consisting of     reference URL (P854)     retrieved (P813)</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>class UrlReference(Reference):\n    \"\"\"\n    Reference consisting of\n        reference URL (P854)\n        retrieved (P813)\n    \"\"\"\n\n    def __init__(\n        self, url, date: Union[str, datetime.date, datetime.datetime, None] = None\n    ):\n        \"\"\"\n        constructor\n        Args:\n            url: reference URL\n            date: retrieved at\n        \"\"\"\n        super().__init__()\n        self.url = url\n        if date is None:\n            date = datetime.date.today()\n        self.date = date\n        self.add(URL(value=self.url, prop_nr=\"P854\"))\n        self.add(Wikidata.get_date_claim(date, prop_nr=\"P813\"))\n</code></pre>"},{"location":"#ez_wikidata.wikidata.UrlReference.__init__","title":"<code>__init__(url, date=None)</code>","text":"<p>constructor Args:     url: reference URL     date: retrieved at</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>def __init__(\n    self, url, date: Union[str, datetime.date, datetime.datetime, None] = None\n):\n    \"\"\"\n    constructor\n    Args:\n        url: reference URL\n        date: retrieved at\n    \"\"\"\n    super().__init__()\n    self.url = url\n    if date is None:\n        date = datetime.date.today()\n    self.date = date\n    self.add(URL(value=self.url, prop_nr=\"P854\"))\n    self.add(Wikidata.get_date_claim(date, prop_nr=\"P813\"))\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata","title":"<code>Wikidata</code>","text":"<p>wikidata access</p> <p>see http://learningwikibase.com/data-import/</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>class Wikidata:\n    \"\"\"\n    wikidata access\n\n    see http://learningwikibase.com/data-import/\n    \"\"\"\n\n    TEST_WD_URL = \"https://test.wikidata.org\"\n    WD_URL = \"https://www.wikidata.org\"\n\n    def __init__(\n        self,\n        baseurl: str = None,\n        wpm: WikidataPropertyManager = None,\n        debug: bool = False,\n    ):\n        \"\"\"\n        Constructor\n\n        Args:\n            baseurl(str): the baseurl of the wikibase to use\n            debug(bool): if True output debug information\n            wpm(WikidataPropertymanager):\n        \"\"\"\n        if baseurl is None:\n            baseurl = self.WD_URL\n        self.baseurl = baseurl\n        self.debug = debug\n        self.apiurl = f\"{self.baseurl}/w/api.php\"\n        self.login = None\n        self.user = None\n        self._wbi = None\n        if wpm is None:\n            wpm = WikidataPropertyManager.get_instance()\n        self.wpm = wpm\n\n    @property\n    def wbi(self) -&gt; WikibaseIntegrator:\n        \"\"\"\n        WikibaseIntegrator\n        \"\"\"\n        if self._wbi is None or (self.login is not None and self._wbi.login is None):\n            wbi_config[\n                \"USER_AGENT\"\n            ] = f\"{Version.name}/{Version.version} (https://www.wikidata.org/wiki/User:{self.user})\"\n            wbi_config[\"MEDIAWIKI_API_URL\"] = self.apiurl\n            self._wbi = WikibaseIntegrator(login=self.login)\n        return self._wbi\n\n    @wbi.setter\n    def wbi(self, wbi: typing.Union[WikibaseIntegrator, None]):\n        \"\"\"\n        set the WikibaseIntegrator\n        \"\"\"\n        self._wbi = wbi\n\n    def getCredentials(self) -&gt; (str, str):\n        \"\"\"\n        get my credentials https://test.wikidata.org/wiki/Property:P370\n\n        from the wd npm command line tool\n\n        Throws:\n            Exception: if no credentials are available for the baseurl\n\n        Returns:\n            (username, password) of the account assigned to the baseurl\n        \"\"\"\n        user = None\n        pwd = None\n        home = str(Path.home())\n        configFilePath = f\"{home}/.config/wikibase-cli/config.json\"\n        if os.path.isfile(configFilePath):\n            with open(configFilePath, mode=\"r\") as f:\n                wikibaseConfigJson = json.load(f)\n                credentials = wikibaseConfigJson[\"credentials\"]\n                credentialRecord = credentials.get(self.baseurl, None)\n                if (\n                    self.baseurl == self.TEST_WD_URL\n                    and self.baseurl not in credentials\n                    and self.WD_URL in credentials\n                ):\n                    credentialRecord = credentials.get(self.WD_URL)\n                if credentialRecord is None:\n                    raise Exception(f\"no credentials available for {self.baseurl}\")\n                user = credentialRecord[\"username\"]\n                pwd = credentialRecord[\"password\"]\n        return user, pwd\n\n    def loginWithCredentials(self, user: str = None, pwd: str = None):\n        \"\"\"\n        login using the given credentials or credentials\n        retrieved via self.getCredentials\n\n        Args:\n            user(str): the username\n            pwd(str): the password\n        \"\"\"\n        if user is None:\n            user, pwd = self.getCredentials()\n\n        if user is not None:\n            self.login = wbi_login.Login(\n                user=user, password=pwd, mediawiki_api_url=self.apiurl\n            )\n            if self.login:\n                self.user = user\n\n    def logout(self):\n        \"\"\"\n        log the user out again\n        \"\"\"\n        self.user = None\n        self.login = None\n        self.wbi = None\n\n    def getItemByName(\n        self, itemName: str, itemType: str, lang: str = \"en\"\n    ) -&gt; typing.Optional[str]:\n        \"\"\"\n        get an item by Name\n        ToDo: Needs to be reworked as always WDQS is used as endpoint even if a different one is defined\n        Args:\n            itemName(str): the item to look for\n            itemType(str): the type of the item\n            lang(str): the language of the itemName\n        \"\"\"\n        itemLabel = f'\"{itemName}\"@{lang}'\n        sparqlQuery = \"\"\"PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\n            PREFIX wdt: &lt;http://www.wikidata.org/prop/direct/&gt;\n            PREFIX wd: &lt;http://www.wikidata.org/entity/&gt;\n\n            SELECT ?item ?itemLabel\n            WHERE {\n              {\n                ?item wdt:P31|wdt:P31/wdt:P279 wd:%s.\n                ?item rdfs:label ?itemLabel.\n                # short name\n                BIND(%s as ?shortNameLabel )\n                ?item wdt:P1813 ?shortNameLabel\n                FILTER(LANG(?itemLabel)= \"%s\" )\n              } UNION {\n                ?item wdt:P31|wdt:P31/wdt:P279 wd:%s.\n                BIND(%s as ?itemLabel )\n                ?item rdfs:label ?itemLabel.\n              }\n            }\"\"\" % (\n            itemType,\n            itemLabel,\n            lang,\n            itemType,\n            itemLabel,\n        )\n        endpointUrl = \"https://query.wikidata.org/sparql\"\n        sparql = SPARQL(endpointUrl)\n        itemRows = sparql.queryAsListOfDicts(sparqlQuery)\n        item = None\n        if len(itemRows) &gt; 0:\n            item = itemRows[0][\"item\"].replace(\"http://www.wikidata.org/entity/\", \"\")\n        return item\n\n    def addDict(\n        self,\n        row: dict,\n        mapDict: dict,\n        itemId: Union[str, None] = None,\n        lang: str = \"en\",\n        write: bool = False,\n        ignoreErrors: bool = False,\n    ) -&gt; WikidataResult:\n        \"\"\"\n        add the given row mapping with the given map Dict\n\n        Args:\n            row(dict): the data row to add\n            mapDict(dict): the mapping dictionary to use\n            itemId: wikidata id of the item the data should be added to. If None a new item is created unless item id is provided in the record\n            lang(str): the language for lookups\n            write(bool): if True do actually write\n            ignoreErrors(bool): if True ignore errors\n\n        Returns:\n            WikiDataResult: the result of the operation\n        \"\"\"\n        mappings = self.wpm.get_mappings_for_records(mapDict)\n        return self.add_record(\n            row,\n            mappings,\n            item_id=itemId,\n            lang=lang,\n            write=write,\n            ignore_errors=ignoreErrors,\n        )\n\n    def get_record(\n        self,\n        item_id: str,\n        property_mappings: Union[\n            List[str], List[\"PropertyMapping\"], typing.Dict[str, dict]\n        ],\n        include_label: bool = True,\n        include_description: bool = True,\n        label_for_qids: bool = False,\n    ) -&gt; dict:\n        \"\"\"\n        Get the properties form the given item\n        Args:\n            item_id: id of the item to get the data from\n            property_mappings: list of property values to extract\n            include_label:\n            include_description:\n            label_for_qids: If True fetch the label for a linked Qid\n        Returns:\n            dict with the property values\n        \"\"\"\n        item = self.wbi.item.get(item_id)\n        lang = \"en\"\n        if isinstance(property_mappings, dict):\n            property_mappings = PropertyMapping.from_records(property_mappings)\n        record = dict()\n        if include_label and item.labels.get(lang) is not None:\n            record[\"label\"] = item.labels.get(lang).value\n        if include_description and item.descriptions.get(lang) is not None:\n            record[\"description\"] = item.descriptions.get(lang).value\n        qualifier_lookup = PropertyMapping.get_qualifier_lookup(property_mappings)\n        pms = []\n        for pm in property_mappings:\n            if not isinstance(pm, PropertyMapping) or not pm.is_qualifier():\n                pms.append(pm)\n        for prop in pms:\n            prop_id = prop\n            if isinstance(prop, PropertyMapping):\n                prop_id = prop.propertyId\n            statements = self._get_statements_by_pid(item, prop_id)\n            prop_label = prop_id\n            if isinstance(prop, PropertyMapping):\n                prop_label = prop.column\n            values = []\n            for statement in statements:\n                value = self._get_statement_value(statement)\n                if label_for_qids:\n                    if (\n                        prop.valueLookupType is not None\n                        and statement.mainsnak.datatype == \"wikibase-item\"\n                    ):\n                        label = self.get_item_label(value, lang)\n                        if label is not None:\n                            value = label\n                values.append(value)\n                if (\n                    isinstance(prop, PropertyMapping)\n                    and prop.column in qualifier_lookup\n                ):\n                    for qualifier_pm in qualifier_lookup[prop.column]:\n                        if qualifier_pm.propertyId in statement.qualifiers.qualifiers:\n                            qualifier_statements = statement.qualifiers.get(\n                                qualifier_pm.propertyId\n                            )\n                        else:\n                            qualifier_statements = []\n                        qualifier_values = []\n                        for qualifier_statement in qualifier_statements:\n                            qualifier_values.append(\n                                self._get_statement_value(qualifier_statement)\n                            )\n                        record[qualifier_pm.column] = (\n                            qualifier_values[0]\n                            if len(qualifier_values) == 1\n                            else qualifier_values\n                        )\n            if len(values) == 1:\n                record[prop_label] = values[0]\n            elif values == []:\n                record[prop_label] = None\n            else:\n                record[prop_label] = values\n        return record\n\n    def get_item_label(self, item_id: str, lang: str = None) -&gt; typing.Union[str, None]:\n        \"\"\"\n        Get the label for the given item id\n        Args:\n            item_id: id of the item\n            lang: label language to return. Default is \"en\"\n\n        Returns:\n            str: label of the item\n            None: If the label can not be determined or the item_id is None or can not be found\n        \"\"\"\n        if lang is None:\n            lang = \"en\"\n        label = None\n        if item_id is not None:\n            linked_item = self.wbi.item.get(item_id)\n            linked_item_label = linked_item.labels.get(lang)\n            if linked_item_label is not None:\n                label = linked_item_label.value\n        return label\n\n    def _get_statements_by_pid(self, item: ItemEntity, pid: str) -&gt; List[Item]:\n        \"\"\"\n        Get the property statements of the item for the given Pid.\n        if ranking is established between the statements return only the highest rank\n        Args:\n            item: item to get the statements from\n            pid: property id\n        Returns:\n            list: list of the property statements\n        \"\"\"\n        if pid in item.claims:\n            statements = item.claims.get(pid)\n        else:\n            statements = []\n        if len(statements) &gt; 1:\n            ordered_stats = {\n                k: list(g) for k, g in groupby(statements, lambda x: x.rank)\n            }\n            rank_by_preference = [\n                WikibaseRank.PREFERRED,\n                WikibaseRank.NORMAL,\n                WikibaseRank.DEPRECATED,\n            ]\n            for rank in rank_by_preference:\n                if rank in ordered_stats:\n                    statements = ordered_stats[rank]\n                    break\n        return statements\n\n    def _get_statement_value(self, statement: Union[Claim, Snak]) -&gt; typing.Any:\n        \"\"\"\n        Get the raw value of the statement without the metadata\n        Args:\n            statement: statement to extract the value from\n\n        Returns:\n            raw value of the statement\n        \"\"\"\n        value = None\n        snak = statement\n        if isinstance(statement, Claim):\n            snak = statement.mainsnak\n        raw_value = snak.datavalue.get(\"value\")\n        datatype = snak.datatype\n        if datatype == \"wikibase-item\":\n            value = raw_value.get(\"id\", None)\n        elif datatype == \"monolingualtext\":\n            value = raw_value.get(\"text\")\n        elif datatype == \"string\":\n            value = raw_value\n        elif datatype == \"url\":\n            value = raw_value\n        elif datatype == \"time\":\n            value = dateutil.parser.parse(raw_value.get(\"time\")[1:])\n            precision = raw_value.get(\"precision\")\n            if precision == 11:\n                value = value.date()\n            elif precision == 9:\n                value = value.year\n        elif datatype == \"external-id\":\n            value = raw_value\n        else:\n            pass\n        return value\n\n    def add_record(\n        self,\n        record: dict,\n        property_mappings: List[\"PropertyMapping\"],\n        item_id: Union[str, None] = None,\n        lang: str = \"en\",\n        write: bool = False,\n        ignore_errors: bool = False,\n        summary: str = None,\n        reference: Reference = None,\n    ) -&gt; WikidataResult:\n        \"\"\"\n        add the given row mapping with the given map Dict\n\n        Args:\n            record(dict): the data row to add\n            property_mappings(list): the mapping dictionary to use\n            item_id: wikidata id of the item the data should be added to. If None a new item is created unless item id is provided in the record\n            lang(str): the language for lookups\n            write(bool): if True do actually write\n            ignore_errors(bool): if True ignore errors\n            summary: summary of the item edits\n            reference: reference to add to all claims\n\n        Returns:\n            (qId, errors): the wikidata item create (if any) and a dict of errors\n        \"\"\"\n        claims = []\n        errors = dict()\n        qualifier_lookup = PropertyMapping.get_qualifier_lookup(property_mappings)\n        # check if there is a existing Q-Item identifier in the record\n        item_mapping = PropertyMapping.get_item_mapping(property_mappings)\n        if item_mapping is not None:\n            if item_id is None:\n                item_id = record.get(item_mapping.column, None)\n        # get the relevant properties\n        properties = []\n        for pm in property_mappings:\n            if not pm.is_qualifier() and not pm.is_item_itself():\n                properties.append(pm)\n            else:\n                # breakpoint to debug ignored properties\n                pass\n\n        for prop in properties:\n            qualifier_mappings = qualifier_lookup.get(prop.column, None)\n            prop_claims, claim_errors = self._get_statement_for_property(\n                record, prop, qualifier_mappings, reference, lang\n            )\n            # merge error dicts to one dict\n            errors = {**errors, **claim_errors}\n            claims.extend(prop_claims)\n        label = self.sanitize_label(record.get(\"label\", None))\n        description = record.get(\"description\", None)\n        # handle get or create case\n        item = self.get_or_create_item(item_id)\n        item.add_claims(claims)\n        if label:\n            item.labels.set(language=lang, value=label)\n        if description:\n            item.descriptions.set(language=lang, value=description)\n        if write:\n            if len(errors) == 0 or ignore_errors:\n                try:\n                    item = item.write(summary=summary)\n                except Exception as ex:\n                    errors[\"write failed\"] = ex\n        result = WikidataResult(item=item, errors=errors, debug=self.debug)\n        return result\n\n    def _get_statement_for_property(\n        self,\n        record: dict,\n        prop_mapping: \"PropertyMapping\",\n        qualifier_mappings: Union[List[\"PropertyMapping\"], None],\n        reference: Reference,\n        lang: str,\n    ) -&gt; (List[Claim], dict):\n        \"\"\"\n        Get the claims that can be derived from the given property mapping and record.\n        Generates a statement with its qualifiers and reference from the given record and mapping.\n        If the record value of the property is a list multiple claims are generated\n\n        Args:\n            record: data record\n            prop_mapping: property definition for the claims that should be generated from the given record\n            qualifier_mappings: descriptions of the qualifiers of the property\n            reference: reference of the statement\n            lang: language to use\n\n        Returns:\n            list of statements\n        \"\"\"\n        claims = []\n        value = self.get_prop_value(record, prop_mapping, lang)\n        values = value if isinstance(value, list) else [value]\n        errors = dict()\n        for value in values:\n            statement = None\n            try:\n                statement = self.convert_to_claim(value=value, pm=prop_mapping)\n            except Exception as ex:\n                errors[prop_mapping.column] = ex\n                if self.debug:\n                    print(traceback.format_exc())\n            if statement is not None:\n                # add reference\n                if reference is not None:\n                    statement.references.add(reference)\n                # add qualifier\n                if qualifier_mappings is not None:\n                    qualifier_errors = self._add_qualifier_to_statement(\n                        record, statement, qualifier_mappings, lang\n                    )\n                    # merge error dicts to one dict\n                    errors = {**errors, **qualifier_errors}\n            if statement is not None:\n                claims.append(statement)\n        return claims, errors\n\n    def _add_qualifier_to_statement(\n        self,\n        record: dict,\n        statement: Claim,\n        qualifier_mappings: List[\"PropertyMapping\"],\n        lang: str,\n    ) -&gt; dict:\n        \"\"\"\n        add the qualifiers to the given statement\n        Args:\n            record:\n            statement: add qualifiers to this statement\n            qualifier_mappings: list of PropertyMappings of the qualifiers\n\n        Returns:\n            dict of occurred errors with the qualifier column as key. If no error occurs an empty dict is returned\n        \"\"\"\n        errors = dict()\n        for qualifier_pm in qualifier_mappings:\n            qualifier_value = self.get_prop_value(record, qualifier_pm, lang)\n            if qualifier_value is None:\n                continue\n            else:\n                try:\n                    qualifier = self.convert_to_claim(qualifier_value, qualifier_pm)\n                    statement.qualifiers.add(qualifier)\n                except Exception as ex:\n                    errors[qualifier_pm.column] = ex\n                    if self.debug:\n                        print(traceback.format_exc())\n        return errors\n\n    def get_or_create_item(self, item_id: typing.Union[str, None]) -&gt; ItemEntity:\n        \"\"\"\n        Get or create the requested wikidata item\n        Args:\n            item_id: item to retrieve if None create a new item\n        \"\"\"\n        if item_id is None or isinstance(item_id, str) and item_id.strip() == \"\":\n            item = self.wbi.item.new()\n        else:\n            item = self.wbi.item.get(item_id)\n        return item\n\n    def get_prop_value(\n        self, record: dict, pm: \"PropertyMapping\", lang: str\n    ) -&gt; typing.Any:\n        \"\"\"\n        Retrieve the property value from the record and prepare the value if necessary\n        Args:\n            record: record containing the property data\n            pm: property mapping\n            lang: language to use\n\n        Returns:\n            value of the property from the record\n        \"\"\"\n        value = record.get(pm.column, None)\n        if value is None:\n            value = pm.value\n        if value and pm.valueLookupType and not self.is_wikidata_item_id(value):\n            # find the wikidata item id of value\n            value = self.getItemByName(value, pm.valueLookupType, lang)\n        if value and isinstance(value, str):\n            value = value.strip()\n        return value\n\n    def convert_to_claim(\n        self, value, pm: \"PropertyMapping\"\n    ) -&gt; Union[BaseDataType, None]:\n        \"\"\"\n        Convert the given value to a corresponding wikidata statement\n        Args:\n            value: value of the statement\n            pm: information about the property statement ot generate\n\n        Raises:\n            Exception: if property datatype is unknown or not supported\n\n        Returns:\n            BaseDataType\n        \"\"\"\n        if value is None or value == \"\":\n            return None\n        if pm.property_type_enum is None:\n            pm.property_type_enum = self.get_wddatatype_of_property(pm.propertyId)\n        if pm.property_type_enum is WdDatatype.year:\n            yearString = f\"+{value}-01-01T00:00:00Z\"\n            statement = Time(\n                yearString, prop_nr=pm.propertyId, precision=WikibaseDatePrecision.YEAR\n            )\n        elif pm.property_type_enum is WdDatatype.date:\n            statement = self.get_date_claim(value, pm.propertyId)\n        elif pm.property_type_enum is WdDatatype.extid:\n            statement = ExternalID(value=value, prop_nr=pm.propertyId)\n        elif pm.property_type_enum is WdDatatype.string:\n            statement = String(value=str(value), prop_nr=pm.propertyId)\n        elif pm.property_type_enum is WdDatatype.text:\n            statement = MonolingualText(text=str(value), prop_nr=pm.propertyId)\n        elif pm.property_type_enum is WdDatatype.url:\n            statement = URL(value=value, prop_nr=pm.propertyId)\n        elif pm.property_type_enum is WdDatatype.itemid:\n            statement = Item(value=value, prop_nr=pm.propertyId)\n        else:\n            raise Exception(\n                f\"({pm.property_type_enum}) unknown or not supported datatype\"\n            )\n        return statement\n\n    @staticmethod\n    def get_date_claim(\n        date: Union[str, datetime.date, datetime.datetime], prop_nr: Union[str, int]\n    ) -&gt; Claim:\n        \"\"\"\n        Get the data statement for the given date and property id\n        Args:\n            date: date value\n            prop_nr: id of the property\n\n        Returns:\n            statement of the given property number with the given value\n        \"\"\"\n        if isinstance(date, datetime.date):\n            date_value = datetime.datetime.combine(date, datetime.time())\n        elif isinstance(date, datetime.datetime):\n            date_value = date\n        elif isinstance(date, str):\n            date_value = dateutil.parser.parse(date)\n        else:\n            raise Exception(f\"Value '{date}' can not be parsed to date\")\n        iso_date = date_value.isoformat()\n        date_string = f\"+{iso_date}Z\"\n        statement = Time(\n            date_string, prop_nr=prop_nr, precision=WikibaseDatePrecision.DAY\n        )\n        return statement\n\n    @staticmethod\n    def is_wikidata_item_id(value: str) -&gt; bool:\n        \"\"\"\n        Returns true if the given value is a wikidata item id\n        \"\"\"\n        return bool(re.fullmatch(r\"Q[0-9]+\", value))\n\n    @staticmethod\n    def is_wikidata_property_id(value: str) -&gt; bool:\n        \"\"\"\n        Returns true if the given value is a wikidata property id\n        \"\"\"\n        return bool(re.fullmatch(r\"P[0-9]+\", value))\n\n    @staticmethod\n    def sanitize_label(label: str, limit: int = None, postfix: str = None) -&gt; str:\n        \"\"\"\n        sanitize given label by ensuring it is not too long\n        Args:\n            label: label to sanitize\n            limit: max length of the label\n\n        Returns:\n            sanitized label\n        \"\"\"\n        if limit is None:\n            limit = 250\n        if postfix is None:\n            postfix = \"...\"\n        if label is not None and len(label) &gt; limit:\n            label = label[: limit - len(postfix)] + postfix\n        return label\n\n    @classmethod\n    def get_datatype_of_property(cls, property_id: Union[str, int]) -&gt; Union[str, None]:\n        \"\"\"\n        Get the datatype of the given property\n        Args:\n            property_id: id of the property e.g. P31 or 31\n\n        Returns:\n            datatype of the property of None if no datatype is defined\n        \"\"\"\n        if isinstance(property_id, int) or not property_id.startswith(\"P\"):\n            property_id = f\"P{property_id}\"\n        query = \"\"\"\n            PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\n            PREFIX wdt: &lt;http://www.wikidata.org/prop/direct/&gt;\n            PREFIX wd: &lt;http://www.wikidata.org/entity/&gt;\n            PREFIX wikibase: &lt;http://wikiba.se/ontology#&gt;\n\n            SELECT Distinct ?o\n            WHERE {\n              wd:%s wikibase:propertyType ?o.\n            }\n        \"\"\" % (\n            property_id\n        )\n        endpointUrl = \"https://query.wikidata.org/sparql\"\n        sparql = SPARQL(endpointUrl)\n        itemRows = sparql.queryAsListOfDicts(query)\n        wikibase_prefix = \"http://wikiba.se/ontology#\"\n        types = []\n        for record in itemRows:\n            types.append(record.get(\"o\")[len(wikibase_prefix) :])\n        if len(types) &gt; 1:\n            print(\"Property has more than one type! please check\")\n        elif len(types) == 0:\n            print(\"Property has no defined datatype! please check\")\n            return None\n        return types[0]\n\n    @classmethod\n    def get_wddatatype_of_property(cls, property_id: Union[str, int]) -&gt; \"WdDatatype\":\n        \"\"\"\n        Get the datatype of the given property\n        Args:\n            property_id: id of the property e.g. P31 or 31\n\n        Returns:\n            WdDatatype of the property of None if no datatype is defined\n        \"\"\"\n        property_type = cls.get_datatype_of_property(property_id)\n        return WdDatatype.get_by_wikibase(property_type)\n\n    def normalize_records(self, record: dict, prop_map: typing.List[\"PropertyMapping\"]):\n        \"\"\"\n        Normalize given record by converting Qids to WikidataItem objects (lookup label) and find out Qid if label given\n        based on the given prop_map\n        \"\"\"\n        itemid_props = [\n            p for p in prop_map if p.property_type_enum is WdDatatype.itemid\n        ]\n        for p in itemid_props:\n            if p.column is None or p.column == \"\":\n                continue\n            value = record.get(p.column, None)\n            if value is None and p.value is not None:\n                value = p.value\n            if isinstance(value, list):\n                wd_item = [self.get_wikidata_item(v, p.valueLookupType) for v in value]\n            else:\n                wd_item = self.get_wikidata_item(value, p.valueLookupType)\n            record[p.column] = wd_item\n        return record\n\n    def get_wikidata_item(\n        self, qid_or_label: str, item_type_qid: str = None\n    ) -&gt; typing.Optional[\"WikidataItem\"]:\n        \"\"\"\n        Get WikidataItem for given label or Qid\n\n        Args:\n            qid_or_label: label or Qid of a item\n\n        Returns:\n            WikidataItem\n        \"\"\"\n        item = None\n        if qid_or_label is not None:\n            if self.is_wikidata_item_id(qid_or_label):\n                # lookup label\n                qid = qid_or_label\n                label = self.get_item_label(qid)\n            else:\n                # lookup label\n                label = qid_or_label\n                qid = self.getItemByName(label, item_type_qid)\n            if qid is not None:\n                item = WikidataItem(qid, label)\n        return item\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata.wbi","title":"<code>wbi: WikibaseIntegrator</code>  <code>property</code> <code>writable</code>","text":"<p>WikibaseIntegrator</p>"},{"location":"#ez_wikidata.wikidata.Wikidata.__init__","title":"<code>__init__(baseurl=None, wpm=None, debug=False)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>baseurl(str)</code> <p>the baseurl of the wikibase to use</p> required <code>debug(bool)</code> <p>if True output debug information</p> required <code>wpm(WikidataPropertymanager)</code> required Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>def __init__(\n    self,\n    baseurl: str = None,\n    wpm: WikidataPropertyManager = None,\n    debug: bool = False,\n):\n    \"\"\"\n    Constructor\n\n    Args:\n        baseurl(str): the baseurl of the wikibase to use\n        debug(bool): if True output debug information\n        wpm(WikidataPropertymanager):\n    \"\"\"\n    if baseurl is None:\n        baseurl = self.WD_URL\n    self.baseurl = baseurl\n    self.debug = debug\n    self.apiurl = f\"{self.baseurl}/w/api.php\"\n    self.login = None\n    self.user = None\n    self._wbi = None\n    if wpm is None:\n        wpm = WikidataPropertyManager.get_instance()\n    self.wpm = wpm\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata.addDict","title":"<code>addDict(row, mapDict, itemId=None, lang='en', write=False, ignoreErrors=False)</code>","text":"<p>add the given row mapping with the given map Dict</p> <p>Parameters:</p> Name Type Description Default <code>row(dict)</code> <p>the data row to add</p> required <code>mapDict(dict)</code> <p>the mapping dictionary to use</p> required <code>itemId</code> <code>Union[str, None]</code> <p>wikidata id of the item the data should be added to. If None a new item is created unless item id is provided in the record</p> <code>None</code> <code>lang(str)</code> <p>the language for lookups</p> required <code>write(bool)</code> <p>if True do actually write</p> required <code>ignoreErrors(bool)</code> <p>if True ignore errors</p> required <p>Returns:</p> Name Type Description <code>WikiDataResult</code> <code>WikidataResult</code> <p>the result of the operation</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>def addDict(\n    self,\n    row: dict,\n    mapDict: dict,\n    itemId: Union[str, None] = None,\n    lang: str = \"en\",\n    write: bool = False,\n    ignoreErrors: bool = False,\n) -&gt; WikidataResult:\n    \"\"\"\n    add the given row mapping with the given map Dict\n\n    Args:\n        row(dict): the data row to add\n        mapDict(dict): the mapping dictionary to use\n        itemId: wikidata id of the item the data should be added to. If None a new item is created unless item id is provided in the record\n        lang(str): the language for lookups\n        write(bool): if True do actually write\n        ignoreErrors(bool): if True ignore errors\n\n    Returns:\n        WikiDataResult: the result of the operation\n    \"\"\"\n    mappings = self.wpm.get_mappings_for_records(mapDict)\n    return self.add_record(\n        row,\n        mappings,\n        item_id=itemId,\n        lang=lang,\n        write=write,\n        ignore_errors=ignoreErrors,\n    )\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata.add_record","title":"<code>add_record(record, property_mappings, item_id=None, lang='en', write=False, ignore_errors=False, summary=None, reference=None)</code>","text":"<p>add the given row mapping with the given map Dict</p> <p>Parameters:</p> Name Type Description Default <code>record(dict)</code> <p>the data row to add</p> required <code>property_mappings(list)</code> <p>the mapping dictionary to use</p> required <code>item_id</code> <code>Union[str, None]</code> <p>wikidata id of the item the data should be added to. If None a new item is created unless item id is provided in the record</p> <code>None</code> <code>lang(str)</code> <p>the language for lookups</p> required <code>write(bool)</code> <p>if True do actually write</p> required <code>ignore_errors(bool)</code> <p>if True ignore errors</p> required <code>summary</code> <code>str</code> <p>summary of the item edits</p> <code>None</code> <code>reference</code> <code>Reference</code> <p>reference to add to all claims</p> <code>None</code> <p>Returns:</p> Type Description <code>(qId, errors)</code> <p>the wikidata item create (if any) and a dict of errors</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>def add_record(\n    self,\n    record: dict,\n    property_mappings: List[\"PropertyMapping\"],\n    item_id: Union[str, None] = None,\n    lang: str = \"en\",\n    write: bool = False,\n    ignore_errors: bool = False,\n    summary: str = None,\n    reference: Reference = None,\n) -&gt; WikidataResult:\n    \"\"\"\n    add the given row mapping with the given map Dict\n\n    Args:\n        record(dict): the data row to add\n        property_mappings(list): the mapping dictionary to use\n        item_id: wikidata id of the item the data should be added to. If None a new item is created unless item id is provided in the record\n        lang(str): the language for lookups\n        write(bool): if True do actually write\n        ignore_errors(bool): if True ignore errors\n        summary: summary of the item edits\n        reference: reference to add to all claims\n\n    Returns:\n        (qId, errors): the wikidata item create (if any) and a dict of errors\n    \"\"\"\n    claims = []\n    errors = dict()\n    qualifier_lookup = PropertyMapping.get_qualifier_lookup(property_mappings)\n    # check if there is a existing Q-Item identifier in the record\n    item_mapping = PropertyMapping.get_item_mapping(property_mappings)\n    if item_mapping is not None:\n        if item_id is None:\n            item_id = record.get(item_mapping.column, None)\n    # get the relevant properties\n    properties = []\n    for pm in property_mappings:\n        if not pm.is_qualifier() and not pm.is_item_itself():\n            properties.append(pm)\n        else:\n            # breakpoint to debug ignored properties\n            pass\n\n    for prop in properties:\n        qualifier_mappings = qualifier_lookup.get(prop.column, None)\n        prop_claims, claim_errors = self._get_statement_for_property(\n            record, prop, qualifier_mappings, reference, lang\n        )\n        # merge error dicts to one dict\n        errors = {**errors, **claim_errors}\n        claims.extend(prop_claims)\n    label = self.sanitize_label(record.get(\"label\", None))\n    description = record.get(\"description\", None)\n    # handle get or create case\n    item = self.get_or_create_item(item_id)\n    item.add_claims(claims)\n    if label:\n        item.labels.set(language=lang, value=label)\n    if description:\n        item.descriptions.set(language=lang, value=description)\n    if write:\n        if len(errors) == 0 or ignore_errors:\n            try:\n                item = item.write(summary=summary)\n            except Exception as ex:\n                errors[\"write failed\"] = ex\n    result = WikidataResult(item=item, errors=errors, debug=self.debug)\n    return result\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata.convert_to_claim","title":"<code>convert_to_claim(value, pm)</code>","text":"<p>Convert the given value to a corresponding wikidata statement Args:     value: value of the statement     pm: information about the property statement ot generate</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if property datatype is unknown or not supported</p> <p>Returns:</p> Type Description <code>Union[BaseDataType, None]</code> <p>BaseDataType</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>def convert_to_claim(\n    self, value, pm: \"PropertyMapping\"\n) -&gt; Union[BaseDataType, None]:\n    \"\"\"\n    Convert the given value to a corresponding wikidata statement\n    Args:\n        value: value of the statement\n        pm: information about the property statement ot generate\n\n    Raises:\n        Exception: if property datatype is unknown or not supported\n\n    Returns:\n        BaseDataType\n    \"\"\"\n    if value is None or value == \"\":\n        return None\n    if pm.property_type_enum is None:\n        pm.property_type_enum = self.get_wddatatype_of_property(pm.propertyId)\n    if pm.property_type_enum is WdDatatype.year:\n        yearString = f\"+{value}-01-01T00:00:00Z\"\n        statement = Time(\n            yearString, prop_nr=pm.propertyId, precision=WikibaseDatePrecision.YEAR\n        )\n    elif pm.property_type_enum is WdDatatype.date:\n        statement = self.get_date_claim(value, pm.propertyId)\n    elif pm.property_type_enum is WdDatatype.extid:\n        statement = ExternalID(value=value, prop_nr=pm.propertyId)\n    elif pm.property_type_enum is WdDatatype.string:\n        statement = String(value=str(value), prop_nr=pm.propertyId)\n    elif pm.property_type_enum is WdDatatype.text:\n        statement = MonolingualText(text=str(value), prop_nr=pm.propertyId)\n    elif pm.property_type_enum is WdDatatype.url:\n        statement = URL(value=value, prop_nr=pm.propertyId)\n    elif pm.property_type_enum is WdDatatype.itemid:\n        statement = Item(value=value, prop_nr=pm.propertyId)\n    else:\n        raise Exception(\n            f\"({pm.property_type_enum}) unknown or not supported datatype\"\n        )\n    return statement\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata.getCredentials","title":"<code>getCredentials()</code>","text":"<p>get my credentials https://test.wikidata.org/wiki/Property:P370</p> <p>from the wd npm command line tool</p> Throws <p>Exception: if no credentials are available for the baseurl</p> <p>Returns:</p> Type Description <code>(str, str)</code> <p>(username, password) of the account assigned to the baseurl</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>def getCredentials(self) -&gt; (str, str):\n    \"\"\"\n    get my credentials https://test.wikidata.org/wiki/Property:P370\n\n    from the wd npm command line tool\n\n    Throws:\n        Exception: if no credentials are available for the baseurl\n\n    Returns:\n        (username, password) of the account assigned to the baseurl\n    \"\"\"\n    user = None\n    pwd = None\n    home = str(Path.home())\n    configFilePath = f\"{home}/.config/wikibase-cli/config.json\"\n    if os.path.isfile(configFilePath):\n        with open(configFilePath, mode=\"r\") as f:\n            wikibaseConfigJson = json.load(f)\n            credentials = wikibaseConfigJson[\"credentials\"]\n            credentialRecord = credentials.get(self.baseurl, None)\n            if (\n                self.baseurl == self.TEST_WD_URL\n                and self.baseurl not in credentials\n                and self.WD_URL in credentials\n            ):\n                credentialRecord = credentials.get(self.WD_URL)\n            if credentialRecord is None:\n                raise Exception(f\"no credentials available for {self.baseurl}\")\n            user = credentialRecord[\"username\"]\n            pwd = credentialRecord[\"password\"]\n    return user, pwd\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata.getItemByName","title":"<code>getItemByName(itemName, itemType, lang='en')</code>","text":"<p>get an item by Name ToDo: Needs to be reworked as always WDQS is used as endpoint even if a different one is defined Args:     itemName(str): the item to look for     itemType(str): the type of the item     lang(str): the language of the itemName</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>def getItemByName(\n    self, itemName: str, itemType: str, lang: str = \"en\"\n) -&gt; typing.Optional[str]:\n    \"\"\"\n    get an item by Name\n    ToDo: Needs to be reworked as always WDQS is used as endpoint even if a different one is defined\n    Args:\n        itemName(str): the item to look for\n        itemType(str): the type of the item\n        lang(str): the language of the itemName\n    \"\"\"\n    itemLabel = f'\"{itemName}\"@{lang}'\n    sparqlQuery = \"\"\"PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\n        PREFIX wdt: &lt;http://www.wikidata.org/prop/direct/&gt;\n        PREFIX wd: &lt;http://www.wikidata.org/entity/&gt;\n\n        SELECT ?item ?itemLabel\n        WHERE {\n          {\n            ?item wdt:P31|wdt:P31/wdt:P279 wd:%s.\n            ?item rdfs:label ?itemLabel.\n            # short name\n            BIND(%s as ?shortNameLabel )\n            ?item wdt:P1813 ?shortNameLabel\n            FILTER(LANG(?itemLabel)= \"%s\" )\n          } UNION {\n            ?item wdt:P31|wdt:P31/wdt:P279 wd:%s.\n            BIND(%s as ?itemLabel )\n            ?item rdfs:label ?itemLabel.\n          }\n        }\"\"\" % (\n        itemType,\n        itemLabel,\n        lang,\n        itemType,\n        itemLabel,\n    )\n    endpointUrl = \"https://query.wikidata.org/sparql\"\n    sparql = SPARQL(endpointUrl)\n    itemRows = sparql.queryAsListOfDicts(sparqlQuery)\n    item = None\n    if len(itemRows) &gt; 0:\n        item = itemRows[0][\"item\"].replace(\"http://www.wikidata.org/entity/\", \"\")\n    return item\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata.get_datatype_of_property","title":"<code>get_datatype_of_property(property_id)</code>  <code>classmethod</code>","text":"<p>Get the datatype of the given property Args:     property_id: id of the property e.g. P31 or 31</p> <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>datatype of the property of None if no datatype is defined</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>@classmethod\ndef get_datatype_of_property(cls, property_id: Union[str, int]) -&gt; Union[str, None]:\n    \"\"\"\n    Get the datatype of the given property\n    Args:\n        property_id: id of the property e.g. P31 or 31\n\n    Returns:\n        datatype of the property of None if no datatype is defined\n    \"\"\"\n    if isinstance(property_id, int) or not property_id.startswith(\"P\"):\n        property_id = f\"P{property_id}\"\n    query = \"\"\"\n        PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\n        PREFIX wdt: &lt;http://www.wikidata.org/prop/direct/&gt;\n        PREFIX wd: &lt;http://www.wikidata.org/entity/&gt;\n        PREFIX wikibase: &lt;http://wikiba.se/ontology#&gt;\n\n        SELECT Distinct ?o\n        WHERE {\n          wd:%s wikibase:propertyType ?o.\n        }\n    \"\"\" % (\n        property_id\n    )\n    endpointUrl = \"https://query.wikidata.org/sparql\"\n    sparql = SPARQL(endpointUrl)\n    itemRows = sparql.queryAsListOfDicts(query)\n    wikibase_prefix = \"http://wikiba.se/ontology#\"\n    types = []\n    for record in itemRows:\n        types.append(record.get(\"o\")[len(wikibase_prefix) :])\n    if len(types) &gt; 1:\n        print(\"Property has more than one type! please check\")\n    elif len(types) == 0:\n        print(\"Property has no defined datatype! please check\")\n        return None\n    return types[0]\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata.get_date_claim","title":"<code>get_date_claim(date, prop_nr)</code>  <code>staticmethod</code>","text":"<p>Get the data statement for the given date and property id Args:     date: date value     prop_nr: id of the property</p> <p>Returns:</p> Type Description <code>Claim</code> <p>statement of the given property number with the given value</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>@staticmethod\ndef get_date_claim(\n    date: Union[str, datetime.date, datetime.datetime], prop_nr: Union[str, int]\n) -&gt; Claim:\n    \"\"\"\n    Get the data statement for the given date and property id\n    Args:\n        date: date value\n        prop_nr: id of the property\n\n    Returns:\n        statement of the given property number with the given value\n    \"\"\"\n    if isinstance(date, datetime.date):\n        date_value = datetime.datetime.combine(date, datetime.time())\n    elif isinstance(date, datetime.datetime):\n        date_value = date\n    elif isinstance(date, str):\n        date_value = dateutil.parser.parse(date)\n    else:\n        raise Exception(f\"Value '{date}' can not be parsed to date\")\n    iso_date = date_value.isoformat()\n    date_string = f\"+{iso_date}Z\"\n    statement = Time(\n        date_string, prop_nr=prop_nr, precision=WikibaseDatePrecision.DAY\n    )\n    return statement\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata.get_item_label","title":"<code>get_item_label(item_id, lang=None)</code>","text":"<p>Get the label for the given item id Args:     item_id: id of the item     lang: label language to return. Default is \"en\"</p> <p>Returns:</p> Name Type Description <code>str</code> <code>Union[str, None]</code> <p>label of the item</p> <code>None</code> <code>Union[str, None]</code> <p>If the label can not be determined or the item_id is None or can not be found</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>def get_item_label(self, item_id: str, lang: str = None) -&gt; typing.Union[str, None]:\n    \"\"\"\n    Get the label for the given item id\n    Args:\n        item_id: id of the item\n        lang: label language to return. Default is \"en\"\n\n    Returns:\n        str: label of the item\n        None: If the label can not be determined or the item_id is None or can not be found\n    \"\"\"\n    if lang is None:\n        lang = \"en\"\n    label = None\n    if item_id is not None:\n        linked_item = self.wbi.item.get(item_id)\n        linked_item_label = linked_item.labels.get(lang)\n        if linked_item_label is not None:\n            label = linked_item_label.value\n    return label\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata.get_or_create_item","title":"<code>get_or_create_item(item_id)</code>","text":"<p>Get or create the requested wikidata item Args:     item_id: item to retrieve if None create a new item</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>def get_or_create_item(self, item_id: typing.Union[str, None]) -&gt; ItemEntity:\n    \"\"\"\n    Get or create the requested wikidata item\n    Args:\n        item_id: item to retrieve if None create a new item\n    \"\"\"\n    if item_id is None or isinstance(item_id, str) and item_id.strip() == \"\":\n        item = self.wbi.item.new()\n    else:\n        item = self.wbi.item.get(item_id)\n    return item\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata.get_prop_value","title":"<code>get_prop_value(record, pm, lang)</code>","text":"<p>Retrieve the property value from the record and prepare the value if necessary Args:     record: record containing the property data     pm: property mapping     lang: language to use</p> <p>Returns:</p> Type Description <code>Any</code> <p>value of the property from the record</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>def get_prop_value(\n    self, record: dict, pm: \"PropertyMapping\", lang: str\n) -&gt; typing.Any:\n    \"\"\"\n    Retrieve the property value from the record and prepare the value if necessary\n    Args:\n        record: record containing the property data\n        pm: property mapping\n        lang: language to use\n\n    Returns:\n        value of the property from the record\n    \"\"\"\n    value = record.get(pm.column, None)\n    if value is None:\n        value = pm.value\n    if value and pm.valueLookupType and not self.is_wikidata_item_id(value):\n        # find the wikidata item id of value\n        value = self.getItemByName(value, pm.valueLookupType, lang)\n    if value and isinstance(value, str):\n        value = value.strip()\n    return value\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata.get_record","title":"<code>get_record(item_id, property_mappings, include_label=True, include_description=True, label_for_qids=False)</code>","text":"<p>Get the properties form the given item Args:     item_id: id of the item to get the data from     property_mappings: list of property values to extract     include_label:     include_description:     label_for_qids: If True fetch the label for a linked Qid Returns:     dict with the property values</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>def get_record(\n    self,\n    item_id: str,\n    property_mappings: Union[\n        List[str], List[\"PropertyMapping\"], typing.Dict[str, dict]\n    ],\n    include_label: bool = True,\n    include_description: bool = True,\n    label_for_qids: bool = False,\n) -&gt; dict:\n    \"\"\"\n    Get the properties form the given item\n    Args:\n        item_id: id of the item to get the data from\n        property_mappings: list of property values to extract\n        include_label:\n        include_description:\n        label_for_qids: If True fetch the label for a linked Qid\n    Returns:\n        dict with the property values\n    \"\"\"\n    item = self.wbi.item.get(item_id)\n    lang = \"en\"\n    if isinstance(property_mappings, dict):\n        property_mappings = PropertyMapping.from_records(property_mappings)\n    record = dict()\n    if include_label and item.labels.get(lang) is not None:\n        record[\"label\"] = item.labels.get(lang).value\n    if include_description and item.descriptions.get(lang) is not None:\n        record[\"description\"] = item.descriptions.get(lang).value\n    qualifier_lookup = PropertyMapping.get_qualifier_lookup(property_mappings)\n    pms = []\n    for pm in property_mappings:\n        if not isinstance(pm, PropertyMapping) or not pm.is_qualifier():\n            pms.append(pm)\n    for prop in pms:\n        prop_id = prop\n        if isinstance(prop, PropertyMapping):\n            prop_id = prop.propertyId\n        statements = self._get_statements_by_pid(item, prop_id)\n        prop_label = prop_id\n        if isinstance(prop, PropertyMapping):\n            prop_label = prop.column\n        values = []\n        for statement in statements:\n            value = self._get_statement_value(statement)\n            if label_for_qids:\n                if (\n                    prop.valueLookupType is not None\n                    and statement.mainsnak.datatype == \"wikibase-item\"\n                ):\n                    label = self.get_item_label(value, lang)\n                    if label is not None:\n                        value = label\n            values.append(value)\n            if (\n                isinstance(prop, PropertyMapping)\n                and prop.column in qualifier_lookup\n            ):\n                for qualifier_pm in qualifier_lookup[prop.column]:\n                    if qualifier_pm.propertyId in statement.qualifiers.qualifiers:\n                        qualifier_statements = statement.qualifiers.get(\n                            qualifier_pm.propertyId\n                        )\n                    else:\n                        qualifier_statements = []\n                    qualifier_values = []\n                    for qualifier_statement in qualifier_statements:\n                        qualifier_values.append(\n                            self._get_statement_value(qualifier_statement)\n                        )\n                    record[qualifier_pm.column] = (\n                        qualifier_values[0]\n                        if len(qualifier_values) == 1\n                        else qualifier_values\n                    )\n        if len(values) == 1:\n            record[prop_label] = values[0]\n        elif values == []:\n            record[prop_label] = None\n        else:\n            record[prop_label] = values\n    return record\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata.get_wddatatype_of_property","title":"<code>get_wddatatype_of_property(property_id)</code>  <code>classmethod</code>","text":"<p>Get the datatype of the given property Args:     property_id: id of the property e.g. P31 or 31</p> <p>Returns:</p> Type Description <code>WdDatatype</code> <p>WdDatatype of the property of None if no datatype is defined</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>@classmethod\ndef get_wddatatype_of_property(cls, property_id: Union[str, int]) -&gt; \"WdDatatype\":\n    \"\"\"\n    Get the datatype of the given property\n    Args:\n        property_id: id of the property e.g. P31 or 31\n\n    Returns:\n        WdDatatype of the property of None if no datatype is defined\n    \"\"\"\n    property_type = cls.get_datatype_of_property(property_id)\n    return WdDatatype.get_by_wikibase(property_type)\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata.get_wikidata_item","title":"<code>get_wikidata_item(qid_or_label, item_type_qid=None)</code>","text":"<p>Get WikidataItem for given label or Qid</p> <p>Parameters:</p> Name Type Description Default <code>qid_or_label</code> <code>str</code> <p>label or Qid of a item</p> required <p>Returns:</p> Type Description <code>Optional[WikidataItem]</code> <p>WikidataItem</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>def get_wikidata_item(\n    self, qid_or_label: str, item_type_qid: str = None\n) -&gt; typing.Optional[\"WikidataItem\"]:\n    \"\"\"\n    Get WikidataItem for given label or Qid\n\n    Args:\n        qid_or_label: label or Qid of a item\n\n    Returns:\n        WikidataItem\n    \"\"\"\n    item = None\n    if qid_or_label is not None:\n        if self.is_wikidata_item_id(qid_or_label):\n            # lookup label\n            qid = qid_or_label\n            label = self.get_item_label(qid)\n        else:\n            # lookup label\n            label = qid_or_label\n            qid = self.getItemByName(label, item_type_qid)\n        if qid is not None:\n            item = WikidataItem(qid, label)\n    return item\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata.is_wikidata_item_id","title":"<code>is_wikidata_item_id(value)</code>  <code>staticmethod</code>","text":"<p>Returns true if the given value is a wikidata item id</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>@staticmethod\ndef is_wikidata_item_id(value: str) -&gt; bool:\n    \"\"\"\n    Returns true if the given value is a wikidata item id\n    \"\"\"\n    return bool(re.fullmatch(r\"Q[0-9]+\", value))\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata.is_wikidata_property_id","title":"<code>is_wikidata_property_id(value)</code>  <code>staticmethod</code>","text":"<p>Returns true if the given value is a wikidata property id</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>@staticmethod\ndef is_wikidata_property_id(value: str) -&gt; bool:\n    \"\"\"\n    Returns true if the given value is a wikidata property id\n    \"\"\"\n    return bool(re.fullmatch(r\"P[0-9]+\", value))\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata.loginWithCredentials","title":"<code>loginWithCredentials(user=None, pwd=None)</code>","text":"<p>login using the given credentials or credentials retrieved via self.getCredentials</p> <p>Parameters:</p> Name Type Description Default <code>user(str)</code> <p>the username</p> required <code>pwd(str)</code> <p>the password</p> required Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>def loginWithCredentials(self, user: str = None, pwd: str = None):\n    \"\"\"\n    login using the given credentials or credentials\n    retrieved via self.getCredentials\n\n    Args:\n        user(str): the username\n        pwd(str): the password\n    \"\"\"\n    if user is None:\n        user, pwd = self.getCredentials()\n\n    if user is not None:\n        self.login = wbi_login.Login(\n            user=user, password=pwd, mediawiki_api_url=self.apiurl\n        )\n        if self.login:\n            self.user = user\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata.logout","title":"<code>logout()</code>","text":"<p>log the user out again</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>def logout(self):\n    \"\"\"\n    log the user out again\n    \"\"\"\n    self.user = None\n    self.login = None\n    self.wbi = None\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata.normalize_records","title":"<code>normalize_records(record, prop_map)</code>","text":"<p>Normalize given record by converting Qids to WikidataItem objects (lookup label) and find out Qid if label given based on the given prop_map</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>def normalize_records(self, record: dict, prop_map: typing.List[\"PropertyMapping\"]):\n    \"\"\"\n    Normalize given record by converting Qids to WikidataItem objects (lookup label) and find out Qid if label given\n    based on the given prop_map\n    \"\"\"\n    itemid_props = [\n        p for p in prop_map if p.property_type_enum is WdDatatype.itemid\n    ]\n    for p in itemid_props:\n        if p.column is None or p.column == \"\":\n            continue\n        value = record.get(p.column, None)\n        if value is None and p.value is not None:\n            value = p.value\n        if isinstance(value, list):\n            wd_item = [self.get_wikidata_item(v, p.valueLookupType) for v in value]\n        else:\n            wd_item = self.get_wikidata_item(value, p.valueLookupType)\n        record[p.column] = wd_item\n    return record\n</code></pre>"},{"location":"#ez_wikidata.wikidata.Wikidata.sanitize_label","title":"<code>sanitize_label(label, limit=None, postfix=None)</code>  <code>staticmethod</code>","text":"<p>sanitize given label by ensuring it is not too long Args:     label: label to sanitize     limit: max length of the label</p> <p>Returns:</p> Type Description <code>str</code> <p>sanitized label</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>@staticmethod\ndef sanitize_label(label: str, limit: int = None, postfix: str = None) -&gt; str:\n    \"\"\"\n    sanitize given label by ensuring it is not too long\n    Args:\n        label: label to sanitize\n        limit: max length of the label\n\n    Returns:\n        sanitized label\n    \"\"\"\n    if limit is None:\n        limit = 250\n    if postfix is None:\n        postfix = \"...\"\n    if label is not None and len(label) &gt; limit:\n        label = label[: limit - len(postfix)] + postfix\n    return label\n</code></pre>"},{"location":"#ez_wikidata.wikidata.WikidataItem","title":"<code>WikidataItem</code>  <code>dataclass</code>","text":"Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>@dataclass\nclass WikidataItem:\n    qid: str\n    label: str\n    lang: str = \"en\"\n    sparql: Optional[SPARQL] = None\n    debug: bool = False\n    label: str = field(init=False, default=None)\n    description: str = field(init=False, default=None)\n    url: str = field(init=False)\n\n    def __eq__(self, other) -&gt; bool:\n        \"\"\"\n        WikidataItems are equal if the qid is equal\n        \"\"\"\n        same = isinstance(other, WikidataItem) and self.qid == getattr(\n            other, \"qid\", None\n        )\n        return same\n\n    def __post_init__(self):\n        \"\"\"\n        handle the construction\n        \"\"\"\n        if not self.qid:\n            self.qid = None\n            return\n        self.url = f\"https://www.wikidata.org/wiki/{self.qid}\"\n        # numeric qid\n        self.qnumber = int(self.qid[1:])\n        self.url = f\"https://www.wikidata.org/wiki/{self.qid}\"\n        if self.sparql is not None:\n            self.qlabel, self.description = WikidataItem.getLabelAndDescription(\n                self.sparql, self.qid, self.lang, debug=self.debug\n            )\n            self.varname = Variable.validVarName(self.qlabel)\n            self.itemVarname = f\"{self.varname}Item\"\n            self.labelVarname = f\"{self.varname}\"\n\n    def __str__(self):\n        return self.asText(long=False)\n\n    def asText(self, long: bool = True, wrapAt: int = 0):\n        \"\"\"\n        returns my content as a text representation\n\n        Args:\n            long(bool): True if a long format including url is wished\n            wrapAt(int): wrap long lines at the given width (if &gt;0)\n\n        Returns:\n            str: a text representation of my content\n        \"\"\"\n        text = self.qid or \"\u2753\"\n        if hasattr(self, \"qlabel\"):\n            text = f\"{self.qlabel} ({self.qid})\"\n        if hasattr(self, \"description\"):\n            desc = self.description\n            if wrapAt &gt; 0:\n                desc = textwrap.fill(desc, width=wrapAt)\n            text += f\"\u261e{desc}\"\n        if long and hasattr(self, \"url\"):\n            text += f\"\u2192 {self.url}\"\n        return text\n\n    @classmethod\n    def getLabelAndDescription(\n        cls, sparql: SPARQL, itemId: str, lang: str = \"en\", debug: bool = False\n    ):\n        \"\"\"\n        get  the label for the given item and language\n\n        Args:\n            itemId(str): the wikidata Q/P id\n            lang(str): the language of the label\n            debug(bool): if True output debug information\n\n        Returns:\n            (str,str): the label and description as a tuple\n        \"\"\"\n        query = f\"\"\"# get the label for the given item\n{Prefixes.getPrefixes([\"rdfs\",\"wd\",\"schema\"])}        \nSELECT ?itemLabel ?itemDescription\nWHERE\n{{\n  VALUES ?item {{\n    wd:{itemId}\n  }}\n  ?item rdfs:label ?itemLabel.\n  FILTER (LANG(?itemLabel) = \"{lang}\").\n  ?item schema:description ?itemDescription.\n  FILTER(LANG(?itemDescription) = \"{lang}\")\n}}\"\"\"\n        try:\n            if debug:\n                msg = f\"getLabelAndDescription for wikidata Item {itemId} with query:\\n{query}\"\n                print(msg)\n            labelAndDescription = sparql.getValues(\n                query, [\"itemLabel\", \"itemDescription\"]\n            )\n        except Exception as ex:\n            msg = f\"getLabelAndDescription failed for wikidata Item {itemId}:{str(ex)}\"\n            if debug:\n                print(msg)\n            raise Exception(msg)\n        return labelAndDescription\n\n    @classmethod\n    def getItemsByLabel(\n        cls, sparql: SPARQL, itemLabel: str, lang: str = \"en\", debug: bool = False\n    ) -&gt; list:\n        \"\"\"\n        get a Wikidata items by the given label\n\n        Args:\n            sparql(SPARQL): the SPARQL endpoint to use\n            itemLabel(str): the label of the items\n            lang(str): the language of the label\n            debug(bool): if True show debugging information\n\n        Returns:\n            a list of potential items\n        \"\"\"\n        valuesClause = f'   \"{itemLabel}\"@{lang}\\n'\n        query = f\"\"\"# get the items that have the given label in the given language\n# e.g. we'll find human=Q5 as the oldest type for the label \"human\" first\n# and then the newer ones such as \"race in Warcraft\"\n{Prefixes.getPrefixes([\"rdfs\",\"schema\",\"xsd\"])}\nSELECT \n  #?itemId \n  ?item \n  ?itemLabel \n  ?itemDescription\nWHERE {{ \n  VALUES ?itemLabel {{\n    {valuesClause}\n  }}\n  #BIND (xsd:integer(SUBSTR(STR(?item),33)) AS ?itemId)\n  ?item rdfs:label ?itemLabel. \n  ?item schema:description ?itemDescription.\n  FILTER(LANG(?itemDescription)=\"{lang}\")\n}} \n#ORDER BY ?itemId\"\"\"\n        qLod = sparql.queryAsListOfDicts(query)\n        items = []\n        for record in qLod:\n            url = record[\"item\"]\n            qid = re.sub(r\"http://www.wikidata.org/entity/(.*)\", r\"\\1\", url)\n            item = WikidataItem(qid, debug=debug)\n            item.url = url\n            item.qlabel = record[\"itemLabel\"]\n            item.varname = Variable.validVarName(item.qlabel)\n            item.description = record[\"itemDescription\"]\n            items.append(item)\n        sortedItems = sorted(items, key=lambda item: item.qnumber)\n        return sortedItems\n</code></pre>"},{"location":"#ez_wikidata.wikidata.WikidataItem.__eq__","title":"<code>__eq__(other)</code>","text":"<p>WikidataItems are equal if the qid is equal</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    \"\"\"\n    WikidataItems are equal if the qid is equal\n    \"\"\"\n    same = isinstance(other, WikidataItem) and self.qid == getattr(\n        other, \"qid\", None\n    )\n    return same\n</code></pre>"},{"location":"#ez_wikidata.wikidata.WikidataItem.__post_init__","title":"<code>__post_init__()</code>","text":"<p>handle the construction</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    handle the construction\n    \"\"\"\n    if not self.qid:\n        self.qid = None\n        return\n    self.url = f\"https://www.wikidata.org/wiki/{self.qid}\"\n    # numeric qid\n    self.qnumber = int(self.qid[1:])\n    self.url = f\"https://www.wikidata.org/wiki/{self.qid}\"\n    if self.sparql is not None:\n        self.qlabel, self.description = WikidataItem.getLabelAndDescription(\n            self.sparql, self.qid, self.lang, debug=self.debug\n        )\n        self.varname = Variable.validVarName(self.qlabel)\n        self.itemVarname = f\"{self.varname}Item\"\n        self.labelVarname = f\"{self.varname}\"\n</code></pre>"},{"location":"#ez_wikidata.wikidata.WikidataItem.asText","title":"<code>asText(long=True, wrapAt=0)</code>","text":"<p>returns my content as a text representation</p> <p>Parameters:</p> Name Type Description Default <code>long(bool)</code> <p>True if a long format including url is wished</p> required <code>wrapAt(int)</code> <p>wrap long lines at the given width (if &gt;0)</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>a text representation of my content</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>def asText(self, long: bool = True, wrapAt: int = 0):\n    \"\"\"\n    returns my content as a text representation\n\n    Args:\n        long(bool): True if a long format including url is wished\n        wrapAt(int): wrap long lines at the given width (if &gt;0)\n\n    Returns:\n        str: a text representation of my content\n    \"\"\"\n    text = self.qid or \"\u2753\"\n    if hasattr(self, \"qlabel\"):\n        text = f\"{self.qlabel} ({self.qid})\"\n    if hasattr(self, \"description\"):\n        desc = self.description\n        if wrapAt &gt; 0:\n            desc = textwrap.fill(desc, width=wrapAt)\n        text += f\"\u261e{desc}\"\n    if long and hasattr(self, \"url\"):\n        text += f\"\u2192 {self.url}\"\n    return text\n</code></pre>"},{"location":"#ez_wikidata.wikidata.WikidataItem.getItemsByLabel","title":"<code>getItemsByLabel(sparql, itemLabel, lang='en', debug=False)</code>  <code>classmethod</code>","text":"<p>get a Wikidata items by the given label</p> <p>Parameters:</p> Name Type Description Default <code>sparql(SPARQL)</code> <p>the SPARQL endpoint to use</p> required <code>itemLabel(str)</code> <p>the label of the items</p> required <code>lang(str)</code> <p>the language of the label</p> required <code>debug(bool)</code> <p>if True show debugging information</p> required <p>Returns:</p> Type Description <code>list</code> <p>a list of potential items</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>    @classmethod\n    def getItemsByLabel(\n        cls, sparql: SPARQL, itemLabel: str, lang: str = \"en\", debug: bool = False\n    ) -&gt; list:\n        \"\"\"\n        get a Wikidata items by the given label\n\n        Args:\n            sparql(SPARQL): the SPARQL endpoint to use\n            itemLabel(str): the label of the items\n            lang(str): the language of the label\n            debug(bool): if True show debugging information\n\n        Returns:\n            a list of potential items\n        \"\"\"\n        valuesClause = f'   \"{itemLabel}\"@{lang}\\n'\n        query = f\"\"\"# get the items that have the given label in the given language\n# e.g. we'll find human=Q5 as the oldest type for the label \"human\" first\n# and then the newer ones such as \"race in Warcraft\"\n{Prefixes.getPrefixes([\"rdfs\",\"schema\",\"xsd\"])}\nSELECT \n  #?itemId \n  ?item \n  ?itemLabel \n  ?itemDescription\nWHERE {{ \n  VALUES ?itemLabel {{\n    {valuesClause}\n  }}\n  #BIND (xsd:integer(SUBSTR(STR(?item),33)) AS ?itemId)\n  ?item rdfs:label ?itemLabel. \n  ?item schema:description ?itemDescription.\n  FILTER(LANG(?itemDescription)=\"{lang}\")\n}} \n#ORDER BY ?itemId\"\"\"\n        qLod = sparql.queryAsListOfDicts(query)\n        items = []\n        for record in qLod:\n            url = record[\"item\"]\n            qid = re.sub(r\"http://www.wikidata.org/entity/(.*)\", r\"\\1\", url)\n            item = WikidataItem(qid, debug=debug)\n            item.url = url\n            item.qlabel = record[\"itemLabel\"]\n            item.varname = Variable.validVarName(item.qlabel)\n            item.description = record[\"itemDescription\"]\n            items.append(item)\n        sortedItems = sorted(items, key=lambda item: item.qnumber)\n        return sortedItems\n</code></pre>"},{"location":"#ez_wikidata.wikidata.WikidataItem.getLabelAndDescription","title":"<code>getLabelAndDescription(sparql, itemId, lang='en', debug=False)</code>  <code>classmethod</code>","text":"<p>get  the label for the given item and language</p> <p>Parameters:</p> Name Type Description Default <code>itemId(str)</code> <p>the wikidata Q/P id</p> required <code>lang(str)</code> <p>the language of the label</p> required <code>debug(bool)</code> <p>if True output debug information</p> required <p>Returns:</p> Type Description <code>(str, str)</code> <p>the label and description as a tuple</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>    @classmethod\n    def getLabelAndDescription(\n        cls, sparql: SPARQL, itemId: str, lang: str = \"en\", debug: bool = False\n    ):\n        \"\"\"\n        get  the label for the given item and language\n\n        Args:\n            itemId(str): the wikidata Q/P id\n            lang(str): the language of the label\n            debug(bool): if True output debug information\n\n        Returns:\n            (str,str): the label and description as a tuple\n        \"\"\"\n        query = f\"\"\"# get the label for the given item\n{Prefixes.getPrefixes([\"rdfs\",\"wd\",\"schema\"])}        \nSELECT ?itemLabel ?itemDescription\nWHERE\n{{\n  VALUES ?item {{\n    wd:{itemId}\n  }}\n  ?item rdfs:label ?itemLabel.\n  FILTER (LANG(?itemLabel) = \"{lang}\").\n  ?item schema:description ?itemDescription.\n  FILTER(LANG(?itemDescription) = \"{lang}\")\n}}\"\"\"\n        try:\n            if debug:\n                msg = f\"getLabelAndDescription for wikidata Item {itemId} with query:\\n{query}\"\n                print(msg)\n            labelAndDescription = sparql.getValues(\n                query, [\"itemLabel\", \"itemDescription\"]\n            )\n        except Exception as ex:\n            msg = f\"getLabelAndDescription failed for wikidata Item {itemId}:{str(ex)}\"\n            if debug:\n                print(msg)\n            raise Exception(msg)\n        return labelAndDescription\n</code></pre>"},{"location":"#ez_wikidata.wikidata.WikidataResult","title":"<code>WikidataResult</code>  <code>dataclass</code>","text":"<p>a class for handling a wikidata result</p> Source code in <code>ez_wikidata/wikidata.py</code> <pre><code>@dataclass\nclass WikidataResult:\n    \"\"\"\n    a class for handling a wikidata result\n    \"\"\"\n\n    item: Optional[ItemEntity] = None\n    errors: Dict[str, Exception] = field(default_factory=dict)\n    qid: Optional[str] = None\n    msg: Optional[str] = None\n    debug: Optional[bool] = False\n\n    def __post_init__(self):\n        # If qid is not provided, derive it from item\n        if self.qid is None and self.item:\n            self.qid = self.item.id\n\n    @property\n    def pretty_item_json(self, indent: int = 2) -&gt; str:\n        \"\"\"Returns a pretty-printed JSON string of the item.\"\"\"\n        if self.item:\n            item_dict = (\n                self.item.get_json()\n            )  # Assuming get_json() returns a JSON string representation of the item\n            pretty_json = json.dumps(item_dict, indent=indent)\n        else:\n            pretty_json = self.qid\n        return pretty_json\n</code></pre>"},{"location":"#ez_wikidata.wikidata.WikidataResult.pretty_item_json","title":"<code>pretty_item_json: str</code>  <code>property</code>","text":"<p>Returns a pretty-printed JSON string of the item.</p>"}]}